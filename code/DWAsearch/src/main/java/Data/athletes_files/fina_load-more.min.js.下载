"use strict";

/*eslint new-cap: ["error", { "newIsCapExceptions": ["filterOptions"] }] */

(function (app, core, common) {
  'use strict';

  /**
   * Load More
   *
   * Load more content via an API request. Will used passed parameters in
   * config to build 'filters' and make correct API request.
   *
   * @param { Object } config - configure the request LoadMore will make.
   * Generally powered by data attributes. Example config:
   *
   * config = {
   *     pageSizeLoadMore: widget.dataset.page-size-loadmore,
   *     pageSize: widget.dataset.page-size,
   *     defaultTags: widget.dataset.tags,
   *     references: widget.dataset.references
   *     playlistTypeRestriction: widget.dataset.playlist-restriction,
   *     contentTypes: widget.dataset.contentTypes.split(',')
   * }
   */
  app.LoadMore = function LoadMore(config) {
    const _self = this;
    const filters = {
      offset: parseInt(config.page * (config.pageSizeLoadMore || config.pageSize), 10),
      limit: parseInt(config.pageSizeLoadMore || config.pageSize, 10),
      tagNames: config.defaultTags,
      references: config.references,
      referenceExpression: config.referenceExpression,
      playlistTypeRestriction: config.playlistTypeRestriction,
      publishedAfter: config.publishedAfter,
      publishedBefore: config.publishedBefore
    };
    _self.filters = new common.filterOptions(filters);
    _self.language = config.language || app.defaultLanguage;
    _self.contentTypes = config.contentTypes;
  };

  /**
   * Get Content
   *
   * @param { Function } callback - Will be called with XHR data when the
   * request has been resolved.
   *
   * @callback callback
   */
  app.LoadMore.prototype.getContent = function getContent(callback) {
    const _self = this;
    const query = _self.buildQuery();
    let requestConfig = {
      url: query.endpoint,
      method: 'GET',
      callback: data => {
        _self.handleResponse(data, callback);
      },
      forceCallback: true,
      target: _self
    };
    core.data.manager.add(requestConfig);
  };

  /**
   * Build Query
   *
   * Get latest filter parameters (as they may have changed since the last
   * request) and then construct the query string for the API request.
   *
   * @returns { Object } query - the query object
   * @returns { Object } query.filterParams - the latest filter params
   * @returns { String } query.type - the query type (if applicable)
   * @returns { String } query.endpoint - the constructed query string
   */
  app.LoadMore.prototype.buildQuery = function buildQuery() {
    const _self = this;
    const query = {};

    // Get up to date filter parameters
    query.filterParams = _self.filters.get();
    query.type = '';
    if (_self.contentTypes.length > 1) {
      query.filterParams.contentTypes = _self.contentTypes.map(type => type.toLowerCase());
    } else {
      query.type = (_self.contentTypes[0] || '').toLowerCase();
    }
    if (query.type === 'playlist') {
      query.filterParams.detail = 'DETAILED';
    }
    query.endpoint = app.common.url.createContentPath(query.type, query.filterParams, _self.language);
    return query;
  };

  /**
   * Handle Response
   *
   * Always called after the XHR request to the API. Job is to update filters
   * for the next request.
   *
   * @param { Object } data - data back from the API
   * @param { Function } callback - callback function will get passed `data`
   * object even if the object is empty.
   */
  app.LoadMore.prototype.handleResponse = function handleResponse(data, callback) {
    const _self = this;
    if (typeof data.content === 'undefined' || data.content.length === 0) {
      console.warn('Data was not received from API');
    }
    _self.filters.updateFilters({
      offset: _self.filters.get().offset + _self.filters.get().limit
    });
    callback(data);
  };
})(PULSE.app, PULSE.core, PULSE.app.common);
"use strict";

(function (app, common) {
  'use strict';

  const OBSERVER_CONFIG = Object.freeze({
    root: null,
    rootMargin: '0px',
    threshold: 0.5
  });
  const {
    U_HIDE,
    IS_LOADING
  } = common.CONSTANTS.CLASSES;
  const SCROLL_LOAD_COUNT = 3;

  /**
   * Infinite Scroll Widget
   *
   * Requires data attributes on container element generated by `loadMoreHeader`
   * macro.
   *
   * @param { DOMElement }  container - the element this was instantiated on
   * @param { Callback } render  - called when there is data to render to the DOM.
   */
  app.InfiniteScrollWidget = function InfiniteScrollWidget(container, render) {
    const _self = this;
    this.pageSizeLoadMore = parseInt(container.getAttribute('data-page-size-loadmore'));
    try {
      const contentTypes = container.getAttribute('data-content-types');
      const filterConfig = {
        language: container.getAttribute('data-language'),
        page: container.getAttribute('data-page'),
        pageSizeLoadMore: this.pageSizeLoadMore,
        pageSize: container.getAttribute('data-page-size'),
        defaultTags: container.getAttribute('data-tags'),
        references: container.getAttribute('data-references'),
        playlistTypeRestriction: container.getAttribute('data-playlist-restriction'),
        contentTypes: contentTypes ? contentTypes.split(',') : null
      };
      _self.loadMore = new app.LoadMore(filterConfig);
    } catch (error) {
      _self.loadMore = function () {/* do nothing */};
      console.error('Unable to load loadMore config', error);
    }
    _self.container = container;
    _self.template = container.getAttribute('data-template');
    _self.featured = container.getAttribute('data-featured');
    _self.observableContainer = container;
    _self.showMoreButton = _self.observableContainer.querySelector('.js-show-more-button');
    _self.render = render;
    _self.loadCounter = 0;
    _self.start();
  };

  /**
   * Handle Callback
   *
   * Always called after XHR request, even when XHR was not successful.
   *
   * @param { Object } data - data from XHR request
   */
  app.InfiniteScrollWidget.prototype.handleCallback = function handleCallback(data) {
    const _self = this;
    if (typeof data.content !== 'undefined' && data.content.length > 0) {
      _self.render(data.content);
    }

    /**
     * Stop scrolling at end of possible page requests.
     */
    if (!data.content?.length || data.content?.length && data.content.length != this.pageSizeLoadMore) {
      _self.stop();
    } else {
      _self.pause();
      _self.loadCounter = 0;
    }
  };

  /**
   * Make Observable Listener
   *
   * Instantiates IntersectionObserver and observes elements.
   */
  app.InfiniteScrollWidget.prototype.makeObservableListener = function makeObservableListener() {
    const _self = this;
    _self.observer = new IntersectionObserver(entries => {
      // we know for a fact that we are binding only one item to this observer instance.
      const [entry] = entries;
      if (entry.isIntersecting) {
        _self.makeRequest();
      }
    }, OBSERVER_CONFIG);
    _self.observer.observe(_self.showMoreButton);
  };

  /**
   * Stop
   *
   * Stop infinite scrolling by observing elements
   */
  app.InfiniteScrollWidget.prototype.stop = function stop() {
    const _self = this;
    _self.observer.disconnect();
    _self.showMoreButton.classList.add(U_HIDE);
    _self.showMoreButton.classList.remove(IS_LOADING);
    _self.showMoreButton.disabled = false;
    _self.showMoreButton.innerText = PULSE.I18N.lookup('label.showMore');
  };

  /**
   * Pause
   *
   * Pause the infinite scrolling requiring the loadmore button to be clicked again
   */
  app.InfiniteScrollWidget.prototype.pause = function pause() {
    const _self = this;
    _self.observer.disconnect();
    _self.showMoreButton.classList.remove(IS_LOADING);
    _self.showMoreButton.disabled = false;
    _self.showMoreButton.innerText = PULSE.I18N.lookup('label.showMore');
  };

  /**
   * Start
   *
   * Start infinite scrolling by making an observable listener.
   */
  app.InfiniteScrollWidget.prototype.start = function start() {
    const _self = this;
    _self.makeObservableListener();
    _self.showMoreButton.classList.remove(U_HIDE);
    _self.showMoreButton.innerText = PULSE.I18N.lookup('label.loading');
    _self.showMoreButton.classList.add(IS_LOADING);
    _self.showMoreButton.disabled = true;
  };

  /**
   * Make Request
   *
   * Makes API request via `loadMore` instance.
   */
  app.InfiniteScrollWidget.prototype.makeRequest = function makeRequest() {
    const _self = this;
    _self.loadMore.getContent(_self.handleCallback.bind(_self));
    _self.loadCounter++;
  };
  document.dispatchEvent(new Event(common.CONSTANTS.EVENTS.INFINITESCROLLWIDGET.READY));
})(PULSE.app, PULSE.app.common);