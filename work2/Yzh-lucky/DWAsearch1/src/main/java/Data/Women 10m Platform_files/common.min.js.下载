"use strict";

PULSE.app.templates['common.paginator'] = _.template("<% for ( var i = 0; i < slideNum; i++ ) { %> <li class=\"pager__container js-pager-container\"> <button class=\"pager__button js-pager\" aria-label=\"Goto Page <%= i + 1 %>\"> <span class=\"u-screen-reader\"><%= i + 1 %></span> </button> </li> <% } %> ");
PULSE.app.templates['common.athlete-headshot'] = _.template("<% if ( typeof id !== 'undefined' && id ) { %> <div class=\"athlete-headshot athlete-headshot--<%= size.toLowerCase() %> <%= cssClass %> u-observed has-placeholder\" data-widget=\"athlete-headshot\" data-init-when-visible=\"true\" data-athlete-id=\"<%= helper.fina.sanitizeResultId( id ) %>\" data-size=\"<%= size %>\" data-object-fit=\"<%= ( typeof objectFit !== 'undefiend' && objectFit ) ? 'true' : 'false' %>\" data-picture-in-view=\"false\"> <%= render( {\n            cssClass: 'athlete-headshot__placeholder',\n            name: 'athlete-silhouette'\n        }, 'common.render-svg' ) %> </div> <% } else { %> <div class=\"athlete-headshot athlete-headshot--<%= size.toLowerCase() %> <%= cssClass %> has-placeholder\"> <%= render( {\n            cssClass: 'athlete-headshot__placeholder',\n            name: 'athlete-silhouette'\n        }, 'common.render-svg' ) %> </div> <% } %>");
PULSE.app.templates['common.competition-item'] = _.template("<div class=\"competition-item <%= typeof cssClass !== 'undefined' ? cssClass : '' %>\"> <% if ( data.group == \"FINA\" ) { %> <a href=\"<%= data.item.competitionLink %>\" class=\"competition-item__link link-underline-trigger\"> <% } %> <div class=\"competition-item__date u-show-tablet\"> <% if ( data.item.dateTbc === true ) { %> <%= PULSE.I18N.lookup( 'label.competition.tbc' ) %> <% } else if ( data.item.isSeasonEvent && data.monthDate ) { %> <%= render( {\n                        comp: data.item,\n                        month: data.monthDate\n                    }, 'common.season-dates' ) %> <% } else { %> <%= PULSE.app.common.date.formatCompDates( data.item.venueDateFrom, data.item.venueDateTo ) %> <% } %> <% if ( typeof data.item.metadata.customStatus !== 'undefined' && data.item.metadata.customStatus.toLowerCase() === 'cancelled' ) { %> <span class=\"competition-item__label competition-item__label--cancelled\"><%= PULSE.I18N.lookup( 'label.competition.cancelled' ) %></span> <% } else if ( typeof data.item.metadata.customStatus !== 'undefined' && data.item.metadata.customStatus ) { %> <span class=\"competition-item__label\"><%= data.item.metadata.customStatus %></span> <% } %> </div> <div class=\"competition-item__main\"> <div class=\"competition-item__date u-hide-tablet\" data-widget=\"format-dates\"> <% if ( data.item.dateTbc === true ) { %> <%= PULSE.I18N.lookup( 'label.competition.tbc' ) %> <% } else if ( data.item.isSeasonEvent && data.monthDate ) { %> <%= render( {\n                            comp: data.item,\n                            month: data.monthDate\n                        }, 'common.season-dates' ) %> <% } else { %> <%= PULSE.app.common.date.formatCompDates( data.item.venueDateFrom, data.item.venueDateTo ) %> <% } %> <% if ( typeof data.item.metadata.customStatus !== 'undefined' && data.item.metadata.customStatus.toLowerCase() === 'cancelled' ) { %> <span class=\"competition-item__label competition-item__label--cancelled\"><%= PULSE.I18N.lookup( 'label.competition.cancelled' ) %></span> <% } else if ( typeof data.item.metadata.customStatus !== 'undefined' && data.item.metadata.customStatus ) { %> <span class=\"competition-item__label\"><%= data.item.metadata.customStatus %></span> <% } %> </div> <% if ( data.group == \"FINA\" ) { %> <div class=\"competition-item__logo-container\"> <%= render( {\n                            cssClass: 'competition-item__placeholder',\n                            name: 'placeholder'\n                        }, 'common.render-svg' ) %> <%= render( {\n                            cssClass: 'competition-item__logo',\n                            compId: data.item.id,\n                            objectFit: true\n                        }, 'common.competition-logo' ) %> </div> <% } %> <div class=\"competition-item__details-container\"> <div class=\"competition-item__details\"> <span class=\"competition-item__name\"><%= data.item.officialName %></span> <% if ( data.item.seriesLabel ) { %> <span class=\"competition-item__stage\"><%= data.item.seriesLabel %></span> <% } %> </div> <% if ( typeof data.item.location !== 'undefined' && data.item.location ) { %> <span class=\"competition-item__location\"> <% if ( data.item.location.countryCode ) { %> <%= render( {\n                                    cssClass: 'competition-item__flag',\n                                    countryCode: data.item.location.countryCode\n                                }, 'common.flag' ) %> <%= data.item.location.countryCode %>, <% } %> <% if ( data.item.location.countryName ) { %> <%= data.item.location.countryName %>, <% } %> <%= data.item.location.city %> </span> <% } %> </div> <% if ( data.group == \"FINA\" ) { %> <div class=\"competition-item__view\"> <% if ( data.type === 'results' ) { %> <span class=\"competition-item__view-text link-underline link-underline--slow u-hide-tablet\"><%= PULSE.I18N.lookup( 'label.view.results' ) %></span> <% } else { %> <span class=\"competition-item__view-text link-underline link-underline--slow u-hide-tablet\"><%= PULSE.I18N.lookup( 'label.view.competition' ) %></span> <% } %> <%= render( {\n                            cssClass: 'competition-item__arrow',\n                            name: 'arrow-forward'\n                        }, 'common.render-svg' ) %> </div> <% } %> </div> <% if ( data.group == \"FINA\" ) { %> </a> <% } %> </div>");
PULSE.app.templates['common.competition-logo'] = _.template("<%\n\tvar objectFit = ( typeof objectFit !== 'undefined' && objectFit ) ? 'true' : 'false';\n\tvar cssClass = ( typeof cssClass !== 'undefined' && cssClass ) ? cssClass : '';\n %> <div class=\"<%= cssClass %>\" data-init-when-visible=\"true\" data-comp-id=\"<%= compId %>\" data-object-fit=\"<%= objectFit %>\" data-size=\"SMALL\" data-widget=\"competition-logo\"> <% /* rendered by JS, if there's a photo available */ %> </div> ");
PULSE.app.templates['common.discipline-icon'] = _.template("<div class=\"discipline-icon <%= typeof cssClass !== 'undefined' ? cssClass : '' %> t-<%= discipline %> discipline-icon--<%= discipline %>\" aria-hidden=\"true\"> <div class=\"discipline-icon__holder\"> <%= render( {\n            name: discipline,\n            cssClass: 'discipline-icon__icon'\n        }, 'common.render-svg' ) %> </div> </div>");
PULSE.app.templates['common.download-cta'] = _.template("<div class=\"download-cta\"> <span class=\"download-cta__cta\"> <%= typeof cta !== 'undefined' ? cta : PULSE.I18N.lookup( 'label.rankings.downloadCTA' ) %> </span> <span class=\"download-cta__links\"> <% _.each( urls, function( url ) { %> <a class=\"download-cta__link link-underline-trigger\" href=\"<%= url.url %>\" target=\"_blank\" rel=\"noopener\"><span class=\"link-underline\"><%= url.label %></span></a> <% } ); %> </span> <span class=\"download-cta__icon-wrapper\"> <%= render( {\n            cssClass: 'download-cta__icon',\n            name: 'download'\n        }, 'common.render-svg' ) %> </span> </div> ");
PULSE.app.templates['common.dynamic-more'] = _.template("<% var classBlock = typeof componentClass !== 'undefined' && componentClass ? componentClass : 'linked-list'; %> <li class=\"dynamic-more <%= classBlock %>__item has-children\"> <span class=\"<%= classBlock %>__item-inner\"> <button class=\"<%= classBlock %>__link <%= classBlock %>__link--dropdown js-dropdown-btn\" aria-haspopup=\"true\"> <span class=\"<%= classBlock %>__link-label-wrap\"> <span class=\"<%= classBlock %>__link-label\"> More <%= render( {\n                        cssClass: classBlock + '__dropdown-icon',\n                        name: 'chevron-right'\n                    }, 'common.render-svg' ) %> </span> </span> </button> <span class=\"<%= classBlock %>__dropdown\"> <ul class=\"<%= classBlock %>__dropdown-list <%= classBlock %>__dropdown--more js-dropdown js-dynamic-more-bucket\" role=\"group\" aria-expanded=\"false\" aria-hidden=\"true\"></ul> </span> </span> </li> ");
PULSE.app.templates['common.flag'] = _.template("<% if ( typeof countryCode !== 'undefined' && countryCode ) { %> <div class=\"flag <%= typeof cssClass !== 'undefined' ? cssClass : '' %>\"> <% var hasCountryCode = countryCode && countryCode !== '?'; %> <img class=\"flag__img\" aria-hidden=\"true\" src=\"<%= environment.cdn %>i/elements/flags/<%= hasCountryCode ? countryCode.toLowerCase() : 'fina' %>.png\" alt=\"<%= hasCountryCode ? countryCode : 'fina' %>\"> </div> <% } %>");
PULSE.app.templates['common.image-element'] = _.template("<img src=\"<%= source %>\" alt=\"<%= title %>\" class=\"img <%= typeof cssClass !== 'undefined' ? cssClass : '' %> <%= fadeInOnLoad ? 'js-faded-image fade-in-on-load' : '' %>\"> ");
PULSE.app.templates['common.lazy-image'] = _.template("<div class=\"js-lazy-load u-observed lazy-image-wrapper <%= typeof data.wrapperCssClass !== 'undefined' ? data.wrapperCssClass : '' %>\" data-picture-in-view=\"false\"> <!-- <% if( data.useImg || data.url ) { %> <%= render( {\n            title: data.title || '',\n            source: data.url,\n            cssClass: data.cssClass || '',\n            objectFit: data.objectFit && true,\n            fadeInOnLoad: true\n        }, 'common.image-element' ) %> <% } else { %> <%= render( {\n            title: data.title || '',\n            mediaQueryConfig: data.mediaQueryConfig,\n            cssClass: data.cssClass || '',\n            objectFit: data.objectFit && true,\n            fadeInOnLoad: true\n        }, 'common.picture-element' ) %> <% } %> --> <!-- DO NOT REMOVE THE ABOVE --> </div>");
PULSE.app.templates['common.loader-single'] = _.template("<div class=\"loader <%= typeof cssClass !== 'undefined' ? cssClass : '' %>\" aria-hidden=\"true\"> <span class=\"loader__bar\"></span> </div>");
PULSE.app.templates['common.loader'] = _.template("<div class=\"loader <%= typeof cssClass !== 'undefined' ? cssClass : '' %>\" aria-hidden=\"true\"> <span class=\"loader__bar\"></span> <span class=\"loader__bar\"></span> <span class=\"loader__bar\"></span> </div>");
PULSE.app.templates['common.picture-element-object-fit'] = _.template("<picture class=\"object-fit-cover-picture <%= typeof cssClass !== 'undefined' ? cssClass : '' %>\" data-photo-id=\"<%= typeof photoId !== 'undefined' ? photoId : '' %>\"> <source srcset=\"<%= thumbnail %>, <%= thumbnailRetina || thumbnail %> 2x\" media=\"(min-width: 640px)\"> <% if( typeof thumbnailMobile !== 'undefined' && typeof thumbnailMobileRetina !== 'undefined' ) { %> <source srcset=\"<%= thumbnailMobile %>, <%= thumbnailMobileRetina %> 2x\" media=\"(max-width: 640px)\"> <% } %> <img class=\"object-fit-cover-picture__img <%= typeof fadeInOnLoad !== 'undefined' && fadeInOnLoad ? 'js-faded-image fade-in-on-load' : '' %>\" src=\"<%= thumbnail %>\"> </picture> ");
PULSE.app.templates['common.picture-element'] = _.template("<% if ( mediaQueryConfig ) { %> <picture class=\"<%= typeof cssClass !== 'undefined' ? cssClass : '' %> <%= objectFit ? 'object-fit-cover-picture' : 'picture' %>\" data-photo-id=\"<%= typeof photoId !== 'undefined' ? photoId : '' %>\"> <% _.each( mediaQueryConfig, function( conf ) { %> <% if ( conf.name === 'default' ) { %> <img class=\"<%= objectFit ? 'object-fit-cover-picture' : 'picture' %>__img <%= typeof imageCssClass !== 'undefined' ? imageCssClass : '' %> <%= typeof fadeInOnLoad !== 'undefined' && fadeInOnLoad ? 'js-faded-image fade-in-on-load' : '' %>\" src=\"<%= conf.variantUrls[ 0 ] %>\" alt=\"<%= title %>\"> <% } else { %> <% var sourceConfig = helper.template.getSourceConfig( conf ) %> <source srcset=\"<%= sourceConfig.srcset %>\" media=\"<%= sourceConfig.mediaQuery %>\"> <% } %> <% } ); %> </picture> <% } %>");
PULSE.app.templates['common.render-legend-item'] = _.template("<%\n    var legendAbbrTranslation = PULSE.I18N.lookup(  'label.' + abbr + '.legend.abbr', {}, true );\n    var asteriskTranslation = typeof asterisk !== 'undefined' ? PULSE.I18N.lookup( 'label.' + asterisk + '.legend.asterisk', {}, true ) : null;\n\n    if ( legendAbbrTranslation || asteriskTranslation ) {\n%> <%\n            if ( legendAbbrTranslation ) {\n                var legendAbbrArr = legendAbbrTranslation.split( '|' );\n                _.each( legendAbbrArr, function( abbr ) {\n        %> <span class=\"results-table__legend-item <%= typeof cssClass !== 'undefined' ? cssClass : '' %>\"><%= abbr %></span> <%\n                } );\n            }\n        %> <% if ( asteriskTranslation ) { %> <span class=\"results-table__legend-item\"> <%= asteriskTranslation %> </span> <% } %> <% } %>");
PULSE.app.templates['common.render-svg'] = _.template("<svg class=\"icon <%= typeof cssClass !== 'undefined' ? cssClass : '' %>\"> <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"<%= environment.cdn %>i/svg-output/icons.svg#icn-<%= name %>\"></use> </svg> ");
PULSE.app.templates['common.season-dates-inner'] = _.template("<% _.each( dates, function( date, index ) { %> <span class=\"season-dates__date\"> <%= date %><%= index < dates.length - 1 ? '<span class=\"season-dates__sep\">,</span>' : '' %> </span> <% } ) %>");
PULSE.app.templates['common.season-dates'] = _.template("<span class=\"season-dates\" data-init-when-visible=\"true\" data-widget=\"season-dates\" data-comp=\"<%= comp.id %>\" data-from=\"<%= comp.venueDateFrom %>\" data-to=\"<%= comp.venueDateTo %>\" data-month-date=\"<%= month %>\"> <span class=\"season-dates__date-loader\"></span> </span>");
"use strict";

(function (common, core) {
  'use strict';

  const INPUT_TYPES = ['click', 'keypress'];
  const MOUSE_DOWN = ['mousedown', 'touchdown'];
  const NO_KEYBOARD_FOCUS = 'js-no-keyboard-focus';
  const KEY_CODES = {
    ENTER: 13,
    ESCAPE: 27,
    ARROW_KEY_LEFT: 37,
    ARROW_KEY_RIGHT: 39,
    SPACE: 32
  };
  common.addAriaClickListener = function (element, callback) {
    let acceptSpace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let useMousedown = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    let useCapture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    // Sometimes when we don't want focus to occur on click we need to bind the mousedown event instead of click.
    const typesToUse = useMousedown ? INPUT_TYPES.filter(type => type !== 'click').concat(MOUSE_DOWN) : INPUT_TYPES;
    const clickEvtType = useMousedown ? MOUSE_DOWN : 'click';
    const callbackWrapper = evt => {
      if (_hasInteracted(evt, acceptSpace, clickEvtType)) {
        return callback(evt);
      }
      return null;
    };
    for (let i = 0; i < typesToUse.length; i++) {
      element.addEventListener(typesToUse[i], callbackWrapper, useCapture);
    }
    return callbackWrapper;
  };
  common.addMultiAriaClickListener = function (elements, callback) {
    let acceptSpace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let useMousedown = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    const elArray = Array.prototype.slice.call(elements);
    elArray.forEach(element => common.addAriaClickListener(element, callback, acceptSpace, useMousedown));
  };
  common.removeAriaClickListener = function (element, callback) {
    let useMousedown = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    // Sometimes when we don't want focus to occur on click we need to bind the mousedown event instead of click.
    const typesToUse = useMousedown ? INPUT_TYPES.filter(type => type !== 'click').concat(MOUSE_DOWN) : INPUT_TYPES;
    for (let i = 0; i < typesToUse.length; i++) {
      element.removeEventListener(typesToUse[i], callback);
    }
  };
  common.resetAriaMenuAttributes = element => {
    element.setAttribute('aria-expanded', 'false');
    element.setAttribute('aria-hidden', 'true');
  };

  /**
   * Toggles any aria attributes for menu for the given element. Determines whether it needs to enable/disable the relevant
   * aria attributes.
   * @param {HTMLElement} element - The element to toggle the ARIA menu attributes on/off
   */
  common.toggleAriaMenuAttributes = element => {
    const ariaExpanded = element.getAttribute('aria-expanded');
    const ariaHidden = element.getAttribute('aria-hidden');
    if (typeof ariaExpanded !== 'undefined') {
      const toggledExpandedValue = ariaExpanded === 'true' ? 'false' : 'true';
      element.setAttribute('aria-expanded', toggledExpandedValue);
    }
    if (typeof ariaHidden !== 'undefined') {
      const toggledHiddenValue = ariaHidden === 'true' ? 'false' : 'true';
      element.setAttribute('aria-hidden', toggledHiddenValue);
    }
  };

  /**
   * Toggles any anchor elements tabindex on the given element. This is to prevent anchors taking keyboard focus
   * when the element is not in view.
   * @param {HTMLElement} element - The element to toggle the tabindex on/off on
   * @param {String}      nodeType - Defaults to anchor tag but allows users to set tab index on non-anchor elements
   */
  common.toggleZIndex = function (element) {
    let nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'a';
    const linkElements = [].slice.call(element.querySelectorAll(nodeType));
    for (let i = 0; i < linkElements.length; i++) {
      const hasDisabledZIndex = linkElements[i].getAttribute('tabindex') === '-1';

      // Should not manipulate z-index on elements that explicitly do not want keyboard focus
      if (core.style.hasClass(linkElements[i], NO_KEYBOARD_FOCUS)) {
        continue;
      }
      if (hasDisabledZIndex && _elementHasDefaultTabindex(nodeType)) {
        linkElements[i].removeAttribute('tabindex');
      } else if (hasDisabledZIndex) {
        linkElements[i].setAttribute('tabindex', '0');
      } else {
        linkElements[i].setAttribute('tabindex', '-1');
      }
    }
  };
  const _elementHasDefaultTabindex = nodeType => {
    return nodeType === 'a';
  };
  const _hasInteracted = (evt, acceptSpace, clickEvtType) => {
    const clickEvtInteracted = Array.isArray(clickEvtType) ? clickEvtType.includes(evt.type) : evt.type === clickEvtType;
    if (evt.which === KEY_CODES.ENTER || clickEvtInteracted) {
      return true;
    }
    if (acceptSpace && evt.which === KEY_CODES.SPACE) {
      return true;
    }
    return false;
  };
})(PULSE.app.common, PULSE.core);
"use strict";

(function (common, core) {
  const BODY = document.body;

  /**
   * Body Scroll
   *
   * Class with methods to disable or enable body scrolling and return the
   * user to the scrolled position when re-enabled.
   *
   * Initiated under common.bodyScroll.
   */
  class BodyScroll {
    constructor() {
      this.disabled = false;
    }

    /**
     * Disable
     *
     * Gets the current scroll position then 'fixes' the body to that
     * current postition.
     */
    disable() {
      this.disabled = true;
      const scrollY = document.documentElement.scrollTop;
      BODY.style.top = `-${scrollY}px`;
      core.style.addClass(BODY, common.CONSTANTS.CLASSES.U_BODY_FIXED);
    }

    /**
     * Enable
     *
     * Remove the class that fixes the scroll and gets then removes the top.
     * Lastly, scrolls the window back to that scroll position.
     */
    enable() {
      this.disabled = false;
      const scrollY = BODY.style.top;
      BODY.style.top = '';
      core.style.removeClass(BODY, common.CONSTANTS.CLASSES.U_BODY_FIXED);
      window.scrollTo(0, parseInt(scrollY || '0') * -1);
    }

    /**
     * Toggle
     *
     * Will enable or disable body scrolling depending on what it is currently
     */
    toggle() {
      if (this.disabled) {
        this.enable();
      } else {
        this.disable();
      }
    }
  }
  common.bodyScroll = new BodyScroll();
})(PULSE.app.common, PULSE.core);
"use strict";

(function (common) {
  /**
   * List of elements to close if the user clicks outside of their defined boundary
   * @type {Array<DOMElement>}
   */
  const elementsToClose = [];

  /**
   * Function to be executed when the click listener on the document is fired
   * @param {DOMEvent} eventObj - The click event
   */
  const onDocumentClick = function (eventObj) {
    let elem;
    for (var i = 0; i < elementsToClose.length; i++) {
      elem = elementsToClose[i];
      if (elem && eventObj.target !== elem.preventTriggerOn && (!elem.preventTriggerOn || !elem.preventTriggerOn.contains(eventObj.target)) && elem.element !== eventObj.target && elem.preventTriggerOn !== eventObj.target && typeof elem.callback === 'function') {
        elem.callback(elem.element);
      }
    }
  };

  /*
   * Functionality which closes all open elements on a document click/click outside of the element
   * element specifically needs to be added to the elementsToClose list
   * @class CloseOnOutsideClick
   * @static
   */
  common.closeOnOutsideClick = {
    /**
     * Adds an element to the elementsToClose list
     * @memberof CloseOnOutsideClick
     *
     * @param {DOMElement} element            - The element
     * @param {Function}   callback           - The callback (gets run on close)
     * @param {DOMElement} preventTriggerOn - Optional element to prevent close on
     */
    addElement: function (element, callback, preventTriggerOn) {
      if (elementsToClose.length === 0) {
        document.addEventListener('click', onDocumentClick);
      }
      elementsToClose.push({
        element,
        callback,
        preventTriggerOn
      });
    },
    /**
     * Removes an element from the elementsToClose list
     * @memberof CloseOnOutsideClick
     *
     * @param {DOMElement} element - The element to remove
     */
    removeElement: function (element) {
      for (let i = 0; i < elementsToClose.length; i++) {
        if (elementsToClose[i] && elementsToClose[i].element === element) {
          elementsToClose.splice(i, 1);
        }
      }
      if (elementsToClose.length === 0) {
        document.removeEventListener('click', onDocumentClick);
      }
    }
  };
})(PULSE.app.common);
"use strict";

(function (common) {
  'use strict';

  common.content = {};
  const DEFAULT_MULTIPLIERS = [1, 2]; // eslint-disable-line no-magic-numbers

  /**
   * Works out whether the content item is tagged with the given tag label
   *
   * @param {ContentResponse} contentItem - Element Item
   * @param {String} tagLabel - Tag
   *
   * @return {Boolean} hasTag?
   */
  common.content.hasTag = function (contentItem, tagLabel) {
    let hasTag = false;
    if (contentItem.tags.length > 0) {
      contentItem.tags.forEach(function (item) {
        if (typeof item.label !== 'undefined' && item.label === tagLabel) {
          hasTag = true;
        }
      });
    }
    return hasTag;
  };

  /**
   * Pre-processing function before using a content response in an underscore template
   * @param {ContentResponse} contentItem The API content response
   * @param {MediaQuerySpecification} mediaQuerySpec Spec on the required variants for the template
   * @param {Boolean} [grid=false] - True/false to return upto 3 items from a playlist, rather than the cover
   * @return {ContentResponse} (extended)
   */
  common.content.getContentModel = function (contentItem, mediaQuerySpec) {
    let grid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let item = contentItem;
    if (item.type !== 'photo') {
      const image = common.content.getImageFromContentItem(item, grid);
      if (Array.isArray(image)) {
        item.mediaQueryConfig = image.map(gridImage => _extendMQConfigWithUrls(gridImage, mediaQuerySpec));
      } else {
        item.mediaQueryConfig = _extendMQConfigWithUrls(image, mediaQuerySpec);
      }
      item.link = common.url.generateUrl(item);
      item.discipline = common.content.getDiscipline(item);
    } else {
      item.mediaQueryConfig = _extendMQConfigWithUrls(item, mediaQuerySpec);
      if (item.playlist) {
        item.link = common.url.generateUrl(item.playlist);
        item.link += common.url.generateUrl(item);
      } else {
        item.link = '';
      }
    }
    return item;
  };

  /**
   * Retrieves the array of photo variants of a content item
   * @param {ContentResponse} contentItem - content data from API
   * @param {Boolean} [grid=false] - True/false to return upto 3 items from a playlist, rather than the cover
   * @return {Array<Variant>} variants
   */
  common.content.getImageFromContentItem = function (contentItem) {
    let grid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let leadMedia;
    if (contentItem.type === 'photo') {
      // Base case for photos: just return the item as-is
      leadMedia = contentItem;
    } else if (contentItem.type === 'video' && contentItem.thumbnail) {
      // Videos have photos as thumbnail items
      leadMedia = contentItem.thumbnail;
    } else if (contentItem.type === 'playlist' && grid) {
      const IMAGES_TO_SHOW = 3;
      let numberOfItems = contentItem.items.length;
      let end = numberOfItems >= IMAGES_TO_SHOW ? IMAGES_TO_SHOW : numberOfItems - 1;
      leadMedia = contentItem.items.slice(0, end).map(item => item.response);
    } else {
      let photoOrVideoCover = contentItem.leadMedia || contentItem.coverItem || contentItem.promoItem;

      // Special case for playlists that have playlists as cover items
      if (contentItem.type === 'playlist' && contentItem.coverItem && contentItem.coverItem.type === 'playlist') {
        photoOrVideoCover = contentItem.coverItem.coverItem;
      }

      // For content items that take photos or videos as cover media
      if (photoOrVideoCover) {
        if (photoOrVideoCover.type === 'photo') {
          leadMedia = photoOrVideoCover;
        } else if (photoOrVideoCover.type === 'video' && photoOrVideoCover.thumbnail) {
          leadMedia = photoOrVideoCover.thumbnail;
        }
      }
    }
    return leadMedia;
  };

  /**
   * Get Content Discipline
   *
   * Given a content item, this will search through its tags to find any
   * "discipline" tags that start with "discipline:". If one is found, its key
   * (everything after the prefix) will be returned. If multiple are found we
   * return "multiple" so the star icon/styling can be displayed.
   *
   * @param {Object} contentItem - A content item that has a tags array
   * @returns {String} The key of the found discipline, or empty, or 'multiple'
   */
  common.content.getDiscipline = function (contentItem) {
    const {
      DISCIPLINE_ALLOW_LIST
    } = common.CONSTANTS;
    let discipline = '';
    if (contentItem.tags.length > 0) {
      for (let i = 0; i < contentItem.tags.length; i++) {
        const tag = contentItem.tags[i];
        if (typeof tag.label !== 'undefined' && tag.label.startsWith('discipline:')) {
          let foundDiscipline = tag.label.replace('discipline:', '');
          if (DISCIPLINE_ALLOW_LIST.includes(foundDiscipline)) {
            // If this is the second disicipline found, then just return 'multiple'
            if (discipline) {
              discipline = 'multiple';
              break;
            }
            discipline = foundDiscipline;
          }
        }
      }
    }
    return discipline;
  };

  /**
   * Works out whether the content item has been associated with a given content reference
   * @param  {Object}                           contentItem - the content item to check
   * @param  {(String|SimpleContentReference)}  reference   - the reference to find
   * @return {Boolean} whether it's found the reference or not
   */
  common.content.hasReference = function hasReference(contentItem, reference) {
    let referenceToFind;
    if (typeof reference === 'string') {
      // Look for strings that have a word, then a colon, then a number i.e. "PHOTO:123456"
      if (reference.match(/(\w):(\d+)/)) {
        referenceToFind = reference.toLowerCase();
      } else {
        console.warn('Tried to match invalid reference string');
        return false;
      }
    } else {
      referenceToFind = `${reference.type.toLowerCase()}:${reference.id}`;
    }
    for (let i = 0; i < contentItem.references.length; i++) {
      const itemReference = contentItem.references[i];
      if (referenceToFind === `${itemReference.type.toLowerCase()}:${itemReference.id}`) {
        return true;
      }
    }
    return false;
  };

  //////////////////////////////
  // Private
  //////

  /**
   * Creates a new mediaQueryConfig object (based on the given one), extended with variant URLs
   * @param  {PhotoResponse}      image          - the image/photo, as retrieved from the API
   * @param  {MediaQueryConfig[]} mediaQuerySpec - the array of configuration for each media source set
   * @return {Object[]}                          - adds a variantUrls property to each config, with the URLs of the variants
   */
  const _extendMQConfigWithUrls = function _extendMQConfigWithUrls(image, mediaQuerySpec) {
    if (image && image.onDemandUrl) {
      return mediaQuerySpec.map(mediaQueryConfig => {
        let conf = {
          ...mediaQueryConfig
        }; // make a copy of the config
        const multipliers = conf.multipliers || DEFAULT_MULTIPLIERS;
        conf.variantUrls = multipliers.map(multiplier => {
          const height = (conf.size.height || 0) * multiplier;
          const width = (conf.size.width || 0) * multiplier;
          return common.image.getOnDemandImageUrl(image, height, width);
        });
        return conf;
      });
    }
    return null;
  };
})(PULSE.app.common);
"use strict";

(function (common) {
  const SECS = 60;
  const MINS = 60;
  const HOURS = 24;
  const TWODAYS = 48;
  const toMillis = 1000;
  common.date = {};

  /**
   * Format Published Ago
   *
   * This is a helper function to see if the published date is within the last
   * 48 hours and if so it will retrun a formatted string to display
   *
   * @param { int } published - Published date as milliseconds from the epoch
   * @param { Boolean } showDate - True will format a date if older than 48 hours
   * @returns { string } - A string to be stored in the model.
   */
  common.date.formatPublishedAgoDate = function formatPublishedAgoDate(published, showDate) {
    const diff = Date.now() - published;
    const cutoff = 172800000; // 48 hours

    let string = '';
    const hours = Math.floor(diff / (SECS * MINS * toMillis));
    const dayjsPublishedDate = dayjs(published);
    if (diff > cutoff) {
      if (showDate) {
        string = dayjsPublishedDate.format('MMMM d, yyyy, HH:mm');
      } else {
        return '';
      }
    } else if (hours === 0) {
      string = PULSE.I18N.lookup('label.timestamp.now'); // NOW
    } else if (hours === 1) {
      string = PULSE.I18N.lookup('label.timestamp.hours.singular');
    } else if (hours > 0 && hours < HOURS) {
      string = PULSE.I18N.lookup('label.timestamp.hours.plural', {
        hours: hours
      });
    } else if (hours >= HOURS && hours < TWODAYS) {
      string = PULSE.I18N.lookup('label.timestamp.days.singular');
    }
    return string;
  };

  /**
   * Get duration in time format mm:ss
   *
   * @param {Int} duration - number of seconds
   * @returns {String} output duration in format mm:ss
   */
  common.durationToTime = function (duration) {
    var secNum = parseInt(duration, 10);
    const hourInSecs = 3600;
    if (secNum) {
      var hours = Math.floor(secNum / hourInSecs);
      var minutes = Math.floor((secNum - hours * hourInSecs) / SECS);
      var seconds = secNum - hours * hourInSecs - minutes * SECS;
      const format = 10;
      if (hours < format) {
        hours = '0' + hours;
      }
      if (minutes < format) {
        minutes = '0' + minutes;
      }
      if (seconds < format) {
        seconds = '0' + seconds;
      }
      var minSec = minutes + ':' + seconds;
      return hours > 0 ? hours + ':' + minSec : minSec;
    }
    return '00:00';
  };

  /**
   * Get Array of Years
   *
   * Get an array of years counting down from a start point to an endpoint,
   * used to populated filter dropdown options.
   *
   * @param {Number} end - The oldest year
   * @param {Number} [start=dayjs().year()] - The year to start from, defaults to current year
   * @returns {Array} Array of years as strings
   */
  common.date.getArrayOfYears = function getArrayOfYears(end, start) {
    const years = [];
    let startYear = start || dayjs().year();

    // Make sure the start year is a number
    if (typeof startYear !== 'number') {
      startYear = Number(start);
      if (isNaN(startYear)) {
        return [];
      }
    }
    let year = startYear;
    while (year >= end) {
      years.push(year);
      year--;
    }
    return years;
  };

  /**
   * Format Comp Dates
   *
   * Format a comps dateFrom and dateTo into a desired output string
   *
   * @param {String} dateFrom - Comp start date in a format accepted by dayjs
   * @param {String} dateTo - Comp end date in a format accepted by dayjs
   * @param {Boolean} longDate - Whether to output the longer version or not
   * @returns {String} - The formated date as a string, ready to render!
   */
  common.date.formatCompDates = function formatCompDates(dateFrom, dateTo) {
    let longDate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    const startDay = dayjs.utc(dateFrom).format('D');
    const endDay = dayjs.utc(dateTo).format('D');
    const startMonth = dayjs.utc(dateFrom).format('M');
    const endMonth = dayjs.utc(dateTo).format('M');

    // If a one day event
    if (startDay === endDay && startMonth === endMonth) {
      const outputFormat = longDate ? 'DD MMM YYYY' : 'MMM DD';
      return dayjs.utc(dateFrom).format(outputFormat);
      // If a multi-day event only in one month
    } else if (startDay !== endDay && startMonth === endMonth) {
      if (longDate) {
        return `${dayjs.utc(dateFrom).format('DD')} - ${dayjs.utc(dateTo).format('DD MMM YYYY')}`;
      }
      return `${dayjs.utc(dateFrom).format('MMM DD')} - ${dayjs.utc(dateTo).format('DD')}`;
    }

    // multi-day event spanning more than one month (fallback)
    if (longDate) {
      return `${dayjs.utc(dateFrom).format('DD MMM')} - ${dayjs.utc(dateTo).format('DD MMM YYYY')}`;
    }
    return `${dayjs.utc(dateFrom).format('MMM DD')} - ${dayjs.utc(dateTo).format('MMM DD')}`;
  };
  common.date.getLocalTime = function getLocalTime(date) {
    const dateObj = new Date(date);
    const localDate = new Date(dateObj.getTime() - dateObj.getTimezoneOffset() * 60 * 1000);
    const hours = localDate.getHours().toString().padStart(2, '0');
    const mins = localDate.getMinutes().toString().padStart(2, '0');
    const formattedTime = `${hours}:${mins}`;
    return formattedTime;
  };
  common.date.getLocalDate = function getLocalTime(date) {
    const dateObj = new Date(date);
    const localDate = new Date(dateObj.getTime() - dateObj.getTimezoneOffset() * 60 * 1000);
    return localDate.toLocaleDateString();
  };
})(PULSE.app.common);
"use strict";

(function (app, common) {
  common.dependency = {};

  /**
   * Loaded
   *
   * Will create a promise that checks for a dependency or listens for when it
   * is ready then resolves.
   *
   * @param {String} dependency - The name of the dependency, how you'd reference it when doing app.
   * @returns {Promise} - A promise that will resolve if the dependency is there or once it loads
   */
  common.dependency.loaded = function (dependency) {
    return new Promise(resolve => {
      if (typeof app[dependency] !== 'undefined') {
        resolve();
      } else {
        document.addEventListener(common.CONSTANTS.EVENTS[dependency.toUpperCase()].READY, resolve);
      }
    });
  };
})(PULSE.app, PULSE.app.common);
"use strict";

(function (common) {
  common.dom = (() => {
    /**
     * The same as Element.closest() with an IE11 polyfill
     * https://developer.mozilla.org/en-US/docs/Web/API/Element/closest
     * @param {HTMLElement} targetElement - the child element
     * @param {DOMString} selector - the selector to query the DOM for
     * @returns {HTMLElement} the closest element to the target element with the passed selector
     */
    const closest = (targetElement, selector) => {
      if (!Element.prototype.closest) {
        let parent;
        // traverse parents
        while (targetElement) {
          parent = targetElement.parentElement;
          if (parent && parent.matches(selector)) {
            return parent;
          }
          targetElement = parent; // eslint-disable-line no-param-reassign
        }
        return null;
      }
      return targetElement.closest(selector);
    };
    return {
      closest
    };
  })();
})(PULSE.app.common);
"use strict";

(function (common) {
  /**
   * generate a new custom event and fire it on the given element
   *
   * @param {String} name the name of the event
   * @param {Object} [data={}] the data to pass to the event
   * @param {HTMLElement} [element=document.body] the element where we should fire the event
   */
  common.fireEvent = function (name) {
    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let element = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document.body;
    element.dispatchEvent(new CustomEvent(name, {
      detail: data
    }));
  };
})(PULSE.app.common);
"use strict";

(function (common, CONSTANTS) {
  /**
   * @const {Number} MIN_SEASON_DURATION - How many days we consider to be the minmum duration of a season event.
   */
  const MIN_SEASON_DURATION = 30;
  common.fina = {};

  /**
   * Get Discipline
   *
   * Given any discipline property, GUID, code or name (defined in constants).
   * This will return the full disicpline object.
   *
   * @param {String} disciplineIdentifier - Code, guid, or lowercase name of the discipline
   * @returns {Object} - The found discipline or an empty object if undefined to avoid errors
   */
  common.fina.getDiscipline = function getDiscipline(disciplineIdentifier) {
    const foundDiscipline = Object.values(CONSTANTS.DISCIPLINES).find(disc => {
      return Object.values(disc).find(prop => prop === disciplineIdentifier);
    });
    return foundDiscipline || {};
  };

  /**
   * Sanitize Athlete Id
   *
   * Sometimes the athlete id is in the data with an R prefix, this checks for
   * it and removes it if it's there.
   *
   * @param {String|Number} athleteResultId - The athlete result ID
   * @returns {String|Number} - The safe resultId
   */
  common.fina.sanitizeResultId = function sanitizeResultId(athleteResultId) {
    /**
     * The Result ID can be a number or a string
     * If it's a string it may begin with an 'R that needs to be removed
     */
    if (typeof athleteResultId === 'string' && athleteResultId.charAt(0) === 'R') {
      // if the first character of the ID is an 'R', remove it
      return athleteResultId.substring(1);
    }
    return athleteResultId;
  };

  /**
   * Medal Letter To Name
   *
   * Convert a single letter denoting a medal to the full name
   *
   * @param {String} letter - A single letter, g,s,b
   * @returns {String} - The full medal name
   */
  common.fina.medalLetterToName = letter => {
    if (!letter) {
      return '';
    }
    switch (letter.toLowerCase()) {
      case 'g':
        return 'gold';
      case 's':
        return 'silver';
      case 'b':
        return 'bronze';
      default:
        return '';
    }
  };

  /**
   * Sort Disciplines By Code
   *
   * Given an array of discipline codes, returns them in the desired order.
   *
   * @param {Array} disciplines - Array of discipline codes
   * @returns {Array} - The sorted disciplines
   */
  common.fina.sortDisciplinesByCode = disciplines => {
    let sortedDisciplines = [];
    for (let i = 0, length = CONSTANTS.DISCIPLINE_ORDER.length; i < length; i++) {
      const item = CONSTANTS.DISCIPLINE_ORDER[i];
      if (disciplines.includes(item)) {
        sortedDisciplines.push(item);
      }
    }
    return sortedDisciplines;
  };

  /**
   * Is Season Event
   *
   * Taking a fina comp, detect if we should class it as a "season" event by
   * checking against the following criteria:
   *
   * - Waterpolo event
   * - Longer than 30 days
   *
   * @param {Object} comp - A fina competition
   * @returns {Boolean} True if a season event
   */
  common.fina.isSeasonEvent = comp => {
    // Reject if comp has no disciplines, is not a WP comp or has no date
    if (!comp.disciplines || !comp.disciplines.includes(CONSTANTS.DISCIPLINES.WATERPOLO.code) || comp.dateTbc) {
      return false;
    }

    // If the from and to dates are more than 30 days apart then accept
    const startDayjs = dayjs.utc(comp.venueDateFrom);
    const endDateDayjs = dayjs.utc(comp.venueDateTo);
    if (endDateDayjs.diff(startDayjs, 'day') > MIN_SEASON_DURATION) {
      return true;
    }
    return false;
  };
})(PULSE.app.common, PULSE.app.common.CONSTANTS);
"use strict";

(function (app, common) {
  common.image = {};

  /**
   * Will return the appropriate variant from a photo, given a tag
   * @param {Array<Variant>} variants - array of variants
   * @param {String} tagLabel - the variant tag label to match against
   * @return {Variant} variant
   */
  common.image.getVariantByTag = function (variants, tagLabel) {
    for (var i = 0; i < variants.length; i++) {
      if (variants[i].tag.label === tagLabel) {
        return variants[i];
      }
    }
    return null;
  };

  /**
   * Retrieves the ODIR-friendly variant URL
   * @param  {PhotoResponse} image  - the image to retrieve the URL from, as it comes from the API (requires "onDemandUrl" to exist under the root)
   * @param  {Number}        height - optional, the desired height
   * @param  {Number}        width  - optional, the desired height
   * @return {String}               - the variant URL
   */
  common.image.getOnDemandImageUrl = function getOnDemandImageUrl(image, height, width) {
    if (image && image.onDemandUrl) {
      let properties = [];
      if (height) {
        properties.push(`height=${height}`);
      }
      if (width) {
        properties.push(`width=${width}`);
      }
      if (properties.length > 0) {
        return `${image.onDemandUrl}?${properties.join('&')}`;
      }
      return `${image.onDemandUrl}?width=500`;
    }
  };

  /**
  * using an array of variants return a variant object with the closest matching width
  * @param {Array} variants an array of variant objects ( from cms api )
  * @param {int} width desired width
  * @returns {object} variant object that most closely matches the desired width
  */
  common.image.getVariantWithWidth = function () {
    let variants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let diff = Infinity;
    let nearest = false;
    variants.forEach((variant, i) => {
      const candidateDiff = Math.abs(variant.width - width);
      if (candidateDiff < diff) {
        diff = candidateDiff;
        nearest = i;
      }
    });
    return variants[nearest];
  };

  /**
   * Given a player photo and a desired set size, it returns the media query config that can be
   * applied to this photo. The set size has a default media query, but we need to check that the
   * original player photo's size works with this. If not, multipliers are removed and the base
   * width/height of the media query config is adjusted to ensure that the photo is never blown up
   * past its maximum size.
   * @param  {Object} playerPhoto        - API photo response
   * @param  {Object} idealMediaQuerySet - media query set to ideally use
   * @return {Object}             - the Media Query Config appropriate for the photo
   */
  common.image.getMediaQuerySet = (playerPhoto, idealMediaQuerySet) => {
    const photoWidth = playerPhoto.originalDetails.width;
    const photoHeight = playerPhoto.originalDetails.height;
    const mediaQueryConfig = idealMediaQuerySet.map(query => {
      const queryWidth = query.size.width;
      const queryHeight = query.size.height;
      let validQuery = {
        ...query
      };
      if (typeof queryWidth !== 'undefined') {
        let multipliers = _getValidMultipliers(photoWidth, queryWidth, query.multipliers);
        if (multipliers.length === 0) {
          validQuery.multipliers = [1];
          validQuery.size.width = photoWidth;
        } else {
          validQuery.multipliers = multipliers;
        }
      }
      if (typeof queryHeight !== 'undefined') {
        let multipliers = _getValidMultipliers(photoHeight, queryHeight, query.multipliers);
        if (multipliers.length === 0) {
          validQuery.multipliers = [1];
          validQuery.size.height = photoHeight;
        } else if (validQuery.multipliers.length > multipliers.length) {
          validQuery.multipliers = multipliers;
        }
      }
      return validQuery;
    });
    return mediaQueryConfig;
  };

  /**
   * Return an array of multipliers that don't make the desired dimension
   * go over the size of the original photo
   * @param  {Number} photoDimension   - the actual dimension of the photo
   * @param  {Number} desiredDimension - the ideal (base) dimension (before multipliers are applied)
   * @param  {Number[]} multipliers    - the multipliers
   * @return {Number[]}                - the multipliers that can be added
   */
  const _getValidMultipliers = (photoDimension, desiredDimension, multipliers) => {
    return multipliers.filter(multiplier => desiredDimension * multiplier <= photoDimension);
  };
})(PULSE.app, PULSE.app.common);
"use strict";

(function (common) {
  /**
   * Prepare Params
   * Turns Key: Value object into ?key=value query string.
   *
   * @param  {Object} params - keys define param name and value the value
   * @returns { String } the query param string
   */
  common.prepareParams = function prepareParams() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const paramsArray = [];
    for (let key in params) {
      if (params.hasOwnProperty(key)) {
        let value = params[key];
        if (typeof value === 'undefined') {
          console.warn(`Value for '${key}' in object 'params' was undefined. The key '${key}' has been omitted from the query string. Please be explicit with values, e.g. boolean or empty string`);
          continue;
        }
        const keyValuePair = [key, encodeURIComponent(value)];
        paramsArray.push(keyValuePair.join('='));
      }
    }
    return paramsArray.length > 0 ? '?' + paramsArray.join('&') : '';
  };
})(PULSE.app.common);
"use strict";

(function (common) {
  'use strict';

  if (typeof common.security === 'undefined') {
    common.security = {};
  }

  /**
   * Will sanitize string for safe use. Removes dangerous characters from
   * string.
   *
   * @param {String} string - string to santize
   * @return {String} - sanitized string
   *
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_parentheses
   */
  common.security.sanitize = string => {
    return string.replace(/(&|<|"|\/|>|\(|\)|;)/g, '');
  };
})(PULSE.app.common);
"use strict";

(function (common) {
  'use strict';

  /**
   * @module TemplateHelpers
   *
   * A combination of utilties to use when templating, these are generally formatters
   * @type {Object}
   */
  common.template = {};

  /**
   * Stringifies & escapes strings so they can be put into HTML
   * @param  {String} string the string to clean
   * @return {String}        output
   */
  common.template.cleanString = function (string) {
    return _.escape(JSON.stringify(string || ''));
  };

  /**
   * Prints a number with commas
   * @param  {Number} number Number value to print with commas as thousands
   * @return {String}        Converted value with commas
   */
  common.template.getNumberWithCommas = function (number) {
    return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
  };

  /**
   * Given a single source variant config, return template-friendly strings
   * @param  {MediaQueryConfig} conf - the media query config for a single source set
   * @return {Object}                - the srcset and media query, in string format
   */
  common.template.getSourceConfig = function getSourceConfig(conf) {
    let srcset = '';
    if (conf.variantUrls.length > 1) {
      srcset = `${conf.variantUrls.join(', ')} 2x`;
    } else {
      srcset = conf.variantUrls.join('');
    }
    let mediaQuery = [];
    if (typeof conf.minWidth !== 'undefined') {
      mediaQuery.push(`(min-width: ${conf.minWidth}px)`);
    }
    if (typeof conf.maxWidth !== 'undefined') {
      mediaQuery.push(`(max-width: ${conf.maxWidth}px)`);
    }
    return {
      srcset,
      mediaQuery: mediaQuery.join(' and ')
    };
  };

  /**
   * Add markup around pipes in a string
   *
   * @param  {String} string - the string to format
   * @return {String}        - the output
   */
  common.template.formatTitle = function formatTitle(string) {
    let newString = string;

    // if there are no delimiters, make the 1st word strong
    if (newString.indexOf('|') === -1) {
      let newStringArray = newString.split(' ');
      newStringArray[0] = `<strong>${newStringArray[0]}</strong>`;
      return newStringArray.join(' ');
    }

    // if there's only one delimiter, add a 2nd
    // eslint-disable-next-line no-magic-numbers
    if (newString.split('|').length % 2 === 0) {
      newString += '|';
    }
    const regexp = /(\|)([^|]+)(\|)/g;
    const matches = string.match(regexp);
    if (matches) {
      matches.forEach(match => {
        let highlight = `<strong>${match.substring(1, match.length - 1)}</strong>`;
        newString = newString.split(match).join(highlight);
      });
    }
    return newString;
  };

  /**
   * Helper for pluralisation of nouns
   *
   * @param {Number} number - the number to base the logic off of
   * @param {String} singular - the singular version of the noun
   * @param {String} plural - the plural version of the noun
   * @param {Boolean} includeNumber - whether to prepend the number to the output string or not
   * @return {String} the pluralized string
   */
  common.template.pluralise = function (number, singular, plural, includeNumber) {
    let string = includeNumber ? number + ' ' : '';
    return string + (number.toString() === '1' ? singular : plural);
  };

  /**
  * Separates the characters of a score for styling purposes#
  * @param {String} string - the string to separate the characters of
  * @param {String} className - class to add to the return html
  * @returns {String} html - the split characters ht,l that is created.
  */
  common.template.separateCharacters = function (string, className) {
    let html = '';
    if (typeof string !== 'undefined') {
      let characterArray = string.toString().split('');
      let cls = className || '';
      for (let i = 0; i < characterArray.length; i++) {
        html += '<span class="' + cls + '">' + characterArray[i] + '</span>';
      }
    }
    return html;
  };

  /**
   * Seo Title
   *
   * Formats a title and aria-label attribute ready to be output in the markup,
   * removing any ".
   *
   * @param {String} title - The title to parse
   * @return {String} - The formated attributes with the parsed title
   */
  common.template.seoTitle = function () {
    let title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    if (title) {
      const escapedTitle = title.replace('"', '');
      return `title="${escapedTitle}" aria-label="${escapedTitle}"`;
    }
    return title;
  };

  /**
   * Truncate Text
   * Truncates a string to a certain number of characters but doesn't
   * break a word. Optional ellipsis.
   *
   * @param {String} string - the string to be truncated
   * @param {Integer} length - the number of characters to truncate by.
   * @param {String} ending - the string to add to the end of the truncated string
   * @return {String} - the formatted string
   */
  common.template.truncateText = function (string, length) {
    let ending = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '...';
    if (!string || !length) {
      return '';
    }
    let initialLength = string.length;
    let formattedString = '';
    if (length > initialLength) {
      return string;
    } else if (string.lastIndexOf(' ', length) >= 0) {
      formattedString = string.slice(0, string.lastIndexOf(' ', length)) + ending;
    } else {
      formattedString = string.slice(0, length) + ending;
    }
    return formattedString;
  };

  /**
   * Takes a NodeList and returns items as an Array
   *
   * @param {Nodelist} nodeList - Node List
   * @return {Array} Node List in form of Array
   */
  common.template.nodeListToArray = nodeList => [].slice.call(nodeList);

  /**
   * Format Duration
   *
   * Formats a number of seconds into a formatted video duration like HH:MM:SS
   *
   * @param {Number} seconds - The seconds value to format
   * @return {String} - The formated duration
   */
  common.template.formatDuration = function (seconds) {
    if (!seconds) {
      return '';
    }
    const duration = dayjs.duration(seconds, 'seconds');
    let timeFormat = 'mm:ss';

    /* Duration conversion isn't supported for durations over 24 hours so we
     * just return nothing :( */
    if (duration.asDays() > 1) {
      return '';
    } else if (duration.asHours() > 1) {
      timeFormat = 'HH:mm:ss';
    }
    return dayjs.utc(duration.asMilliseconds()).format(timeFormat);
  };
})(PULSE.app.common);
"use strict";

(function (core, app, common) {
  common.url = {};

  /**
   * creates content path based on the type and parameters
   * @param {String} type Type of content
   * @param {Object} params query params (to be used as GET params)
   * @param {String} lang   the API language; defaults to english
   * @param {Number} id     ID of the item if requesting only one
   * @returns {String} url Content url
   */
  common.url.createContentPath = function (type, params, lang, id) {
    var contentType = type ? type.toLowerCase() + '/' : '';
    var url = app.environment.api + '/content/' + app.account + '/' + contentType + (lang ? lang : app.defaultLanguage).toLowerCase() + '/' + (id ? id : '');
    if (params) {
      url += '?' + core.url.buildQueryString(params);
    }
    return url;
  };

  /**
   * generate a url for a some content
   * @param {Object} content - content response from the API
   * @returns {String} url Link to content
   */
  common.url.generateUrl = function (content) {
    let url = '//' + app.environment.domain;
    const contentType = content.type.toLowerCase();
    if (content.hotlinkUrl) {
      return url + content.hotlinkUrl;
    }
    switch (contentType) {
      case 'text':
        url += `/news/${content.id}/${content.titleUrlSegment || common.url.urlify(content.title)}`;
        return url;
      case 'video':
        url += `/videos/${content.id}/${content.titleUrlSegment || common.url.urlify(content.title)}`;
        return url;
      case 'playlist':
        if (content.typeRestriction && content.typeRestriction.toLowerCase() === 'photo') {
          url += `/photos/${content.id}/${content.titleUrlSegment || common.url.urlify(content.title)}`;
        }
        return url;
      case 'photo':
        url += `${common.url.generateUrl(content.playlist)}/${content.id}/`;
        if (content.description) {
          url += common.url.urlify(content.description);
        }
        return url;
      default:
        return '';
    }
  };

  /**
   * generates a url for a competition listing
   * @param {Number} competitionId - Id of the competition
   * @param {String} officialName - Id of the competition Type
   * @returns {String} url Link to content
   */
  common.url.generateCompUrl = function (competitionId, officialName) {
    if (competitionId && officialName) {
      return `/competitions/${competitionId}/${common.url.urlify(officialName)}`;
    }
    return '';
  };

  /**
   * generates a url for a results listing
   * @param {Number} competitionId - Id of the competition
   * @param {Guid} eventName - The name of the event
   * @param {Object} params - Any params to add to the URL
   * @returns {String} url Link to content
   */
  common.url.generateResultsUrl = function (competitionId, eventName, params) {
    if (competitionId && eventName) {
      return `/competitions/${competitionId}/${common.url.urlify(eventName)}/results${common.prepareParams(params)}`;
    }
    return '/';
  };

  /**
   * generates a url for an athlete listing
   * @param {String|Number} athleteResultId - ResultId for an athlete
   * @param {String} athleteName - Athlete fullname
   * @param {String} [nationality=''] - If provided and === 'CLB' then don't return a link
   * @returns {String} url Link to content
   */
  common.url.generateAthleteUrl = function (athleteResultId) {
    let athleteName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    let nationality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    // Remove undefined and null and any white space to check for completly empty concatenated names
    const trimmedName = athleteName.replace('null', '').replace('undefined', '').replace(' ', '');
    if (!athleteResultId || nationality === 'CLB' || athleteName === '' || trimmedName.length === 0) {
      return null;
    }
    let id = common.fina.sanitizeResultId(athleteResultId);
    const urlName = athleteName ? `/${common.url.urlify(athleteName)}` : '';
    return `//${app.environment.domain}/athletes/${id}${urlName}`;
  };
  common.url.urlify = function (str) {
    return str.toLowerCase().replace(/[^a-z0-9]+/gi, '-').replace(/-{2,}/g, '-').replace(/^-|-$/g, '');
  };

  /* eslint-disable array-callback-return, consistent-return */

  /**
   * Retrieves tags & content references from an URL request
   * @param  {String} url - the URL
   * @return {Object}     - the filter
   */
  common.url.getFilterFromRequest = url => {
    let filter = {};
    ['tagNames', 'tagExpression', 'references', 'referenceExpression'].forEach(urlParam => {
      const rawValue = core.url.getParameterByName(urlParam, url);
      if (rawValue) {
        const delimiter = urlParam.search('Expression') > -1 ? ' or ' : ',';
        filter[urlParam] = rawValue.split(delimiter).map(value => {
          // Remove whitespace and any wrapping quote marks
          const trimmedValue = value.trim().replace(/['"]+/g, '');
          if (urlParam.search('reference') === -1) {
            return trimmedValue;
          }
          const contentReferenceMatches = trimmedValue.match(/(\w+):(\d+)/);
          if (contentReferenceMatches && contentReferenceMatches.length) {
            return {
              type: contentReferenceMatches[1],
              id: contentReferenceMatches[2]
            };
          }
        }).filter(value => typeof value !== 'undefined');
      }
    });
    return filter;
  };

  /* eslint-enable array-callback-return, consistent-return */

  /**
   * Params To Object
   * Convert a query param string to an object of key/value pairs
   *
   * @param {String} urlParams - the result of location.search
   * @returns {Object} an object of query param key/value pairs
   */
  common.url.paramsToObject = urlParams => {
    const paramsObject = {};
    for (const [key, value] of urlParams) {
      // each 'entry' is a [key, value] tupple
      paramsObject[key] = value;
    }
    return paramsObject;
  };
})(PULSE.core, PULSE.app, PULSE.app.common);
"use strict";

(function (common) {
  common.widget = {};

  /**
   * Gets a data attribute of a DOM element and converts it to a number
   *
   * @param  {string}     attribute     The attribute name
   * @param  {DOMElement} element       The element
   * @param  {boolean}    [isFloat]     Whether number passed is a float
   * @return {Number|undefined}                   The number attribute.
   */
  common.widget.getNumberAttribute = function (attribute, element, isFloat) {
    let value;
    if (isFloat) {
      value = parseFloat(element.getAttribute(attribute));
    } else {
      value = parseInt(element.getAttribute(attribute), 10);
    }
    if (isNaN(value) === false) {
      return value;
    }
    return null;
  };

  /**
   * Gets the data attribute of a DOM element and converts it into an array
   *
   * @param  {string}        attribute  The attribute name
   * @param  {DOMElement}    element    The element
   * @return {Array<String>}            The array attribute.
   */
  common.widget.getArrayAttribute = function (attribute, element) {
    let value = element.getAttribute(attribute);
    if (value) {
      return value.split(',').map(item => item.trim()).filter(item => typeof item !== 'undefined' && item !== '');
    }
    return [];
  };
})(PULSE.app.common);
"use strict";

/**
 * Pulse Fina Endpoints
 *
 * Docs are here: http://swagger.pulselive.com/
 */
(function (app, common) {
  'use strict';

  if (typeof common.endpoints === 'undefined') {
    common.endpoints = {};
  }
  const finaAPI = app.environment.finaApi;
  const prepareParams = common.prepareParams;
  common.endpoints.fina = {
    athletes: {
      all: params => `${finaAPI}/athletes${prepareParams(params)}`,
      single: (id, params) => `${finaAPI}/athletes/${id}${prepareParams(params)}`,
      bio: id => `${finaAPI}/athletes/${id}/bio`,
      results: (id, params) => `${finaAPI}/athletes/${id}/results${prepareParams(params)}`
    },
    competitions: {
      all: params => `${finaAPI}/competitions${prepareParams(params)}`,
      single: (id, params) => `${finaAPI}/competitions/${id}${prepareParams(params)}`,
      medals: (competitionId, params) => `${finaAPI}/competitions/${competitionId}/medals${prepareParams(params)}`,
      schedule: (id, params) => `${finaAPI}/competitions/${id}/schedule${prepareParams(params)}`,
      athletes: (id, params) => `${finaAPI}/competitions/${id}/athletes${prepareParams(params)}`,
      events: (id, params) => `${finaAPI}/competitions/${id}/events${prepareParams(params)}`,
      ics: params => `${finaAPI}/competitions/ics${prepareParams(params)}`
    },
    event: id => `${finaAPI}/events/${id}`,
    rankings: {
      swimming: params => `${finaAPI}/rankings/swimming${prepareParams(params)}`,
      openWaterSwimming: params => `${finaAPI}/rankings/openWaterSwimming${prepareParams(params)}`,
      waterPoloSwimming: params => `${finaAPI}/rankings/waterPolo${prepareParams(params)}`,
      diving: (eventId, params) => `${finaAPI}/rankings/diving/${eventId}${prepareParams(params)}`,
      series: scoringId => `${finaAPI}/rankings/series/${scoringId}`,
      swimmingReport: (format, params) => `${finaAPI}/rankings/swimming/report/${format}${prepareParams(params)}`,
      openWaterSwimmingReport: (format, params) => `${finaAPI}/rankings/openWaterSwimming/report/${format}${prepareParams(params)}`,
      waterPoloSwimmingReport: (format, params) => `${finaAPI}/rankings/waterPolo/report/${format}${prepareParams(params)}`,
      divingReport: params => `${finaAPI}/rankings/diving/report${prepareParams(params)}`
    },
    records: {
      swimming: params => `${finaAPI}/records/SW${prepareParams(params)}`,
      report: params => `${finaAPI}/records/report${prepareParams(params)}`
    },
    countries: {
      all: () => `${finaAPI}/countries`
    },
    development: {
      calendar: params => `${finaAPI}/development/calendar${prepareParams(params)}`,
      ics: params => `${finaAPI}/development/calendar/ics${prepareParams(params)}`
    },
    officials: id => `${finaAPI}/officials/${id}`,
    results: params => `${finaAPI}/results/live${prepareParams(params)}`
  };
})(PULSE.app, PULSE.app.common);
"use strict";

(function (app, request, CONSTANTS, urlHelper) {
  'use strict';

  /**
   * The maximum photos to request at once
   * @type {Number}
   */
  const MAX_REQUEST_ITEMS = 100;

  /**
   * The number of different CRs to batch together
   * @type {Number}
   */
  const BATCH_SIZE = 10;

  /**
   * How long to wait until launching a new request
   * @type {Number}
   */
  const REQUEST_TIMEOUT_DURATION = 500; // half a second

  /**
   * Bulks up photo requests by grouping them by tags
   * It'll do one request for multiple items,
   * @constructor BatchedRequest
   * @param {String} filterId - the identifier for the filter group
   * @param {String|Boolean} groupBy  - "tags" or "references" or "false" for no grouping
   * @param {String} [contentType="photo"] - the content type to request
   */
  app.common.BatchedRequest = function (filterId, groupBy) {
    let contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'photo';
    this.filterId = filterId;
    this.references = [];
    this.groupBy = groupBy === false ? false : groupBy === 'references' ? 'references' : 'tags';
    this.contentType = contentType;
    this.pendingItems = [];
  };

  /**
   * Adds an item to the batched request manager
   * @param {Object} filter - the filter
   */
  app.common.BatchedRequest.prototype.addItem = function (filter) {
    this.pendingItems.push(filter);
    this.triggerTimeout();
  };

  /**
   * Gets photos; will batch up in multiple requests if too many items are being asked for
   * at any one time
   */
  app.common.BatchedRequest.prototype.getPhotos = function () {
    const batchedItems = _chunk(this.pendingItems, BATCH_SIZE);
    batchedItems.forEach(batch => _makeRequest.call(this, batch));
    if (this.requestTimeout) {
      delete this.requestTimeout;
    }
    this.pendingItems = [];
  };

  /**
   * Makes a request to the content API given a number of items to extract a filter from
   * @param  {Object[]} items - the items to get the filter from
   */
  const _makeRequest = function _makeRequest(items) {
    const filter = _makeGroupFilter(items, this.groupBy);
    const tags = filter.tags;
    const references = filter.references;
    let requestParameters = {
      limit: MAX_REQUEST_ITEMS
    };
    if (this.groupBy === 'tags') {
      requestParameters.tagNames = tags.join(',');
      const quotedReferences = references.map(reference => `"${reference}"`);
      requestParameters.referenceExpression = quotedReferences.join(' or ');
    } else {
      const quotedTags = tags.map(tag => `"${tag}"`);
      const quotedReferences = references.map(reference => `"${reference}"`);
      requestParameters.tagExpression = quotedTags.join(' or ');
      requestParameters.references = quotedReferences.join(',');
    }
    const url = app.common.url.createContentPath(this.contentType, requestParameters);
    request(url, 'GET', _requestCallback.bind(this), this);
  };

  /**
   * Creates a new timeout window if there isn't one, so pending filters may be grouped together
   */
  app.common.BatchedRequest.prototype.triggerTimeout = function () {
    if (!this.requestTimeout) {
      this.requestTimeout = setTimeout(this.getPhotos.bind(this), REQUEST_TIMEOUT_DURATION);
    }
  };

  /**
   * Callback for the photo data request
   * @param  {Object} photoData - photo data
   */
  const _requestCallback = function _requestCallback(photoData) {
    const requestFilter = urlHelper.getFilterFromRequest(photoData.fullXhttpResponse.responseURL);
    app.common.fireEvent(CONSTANTS.EVENTS.PHOTO_MARKER.NEW_DATA, {
      groupId: this.filterId,
      filter: requestFilter,
      data: photoData
    });
  };

  /**
   * Combines a list of filters into one filter, based on the property to group them by
   * @param  {Object[]} filters - array of filters
   * @param  {String}   groupBy - what to group filtering by
   * @return {Object} object with tags and content references
   */
  const _makeGroupFilter = (filters, groupBy) => {
    let tags = [];
    let references = [];
    filters.forEach(filter => {
      if (groupBy === 'tags') {
        if (filter.references) {
          references.push(_flattenReferences(filter.references).join(' and '));
        }
        if (filter.tags && tags.length === 0) {
          tags.push(filter.tags);
        }
      } else if (groupBy === 'references') {
        if (filter.tags) {
          tags.push(filter.tags.join(' and '));
        }
        if (filter.references && references.length === 0) {
          references = _flattenReferences(filter.references);
        }
      } else {
        if (filter.tags) {
          tags.push(filter.tags.join('or'));
        }
        if (filter.references) {
          references.push(_flattenReferences(filter.references).join(' or '));
        }
      }
    });
    return {
      tags,
      references
    };
  };

  /**
   * Given an array of strings or SimpleContentReference objects,
   * returns an array of strings representing these references
   * @param  {SimpleContentReference[]} references - the references
   * @return {String[]}                            - array of CR strings
   */
  const _flattenReferences = references => {
    return references.map(reference => {
      if (typeof reference === 'string') {
        return reference;
      }
      return `${reference.type}:${reference.id}`;
    });
  };

  /**
   * Splits an array up into an array of arrays of a given size
   * @param  {Array}  array      - any type of iterable array
   * @param  {Number} chunkSize  - the size of the resulting component arrays
   * @return {Array[]}           - an array of arrays
   */
  const _chunk = (array, chunkSize) => {
    let chunkedArray = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunkedArray.push(array.slice(i, i + chunkSize));
    }
    return chunkedArray;
  };
})(PULSE.app, PULSE.core.data.request, PULSE.app.common.CONSTANTS, PULSE.app.common.url);
"use strict";

(function (app, CONSTANTS, contentHelper) {
  'use strict';

  /**
   * Notification that a new marker's ready to receive data
   * @type {String}
   */
  const NEW_MARKER_EVENT = CONSTANTS.EVENTS.PHOTO_MARKER.WAITING;

  /**
   * Bulks up photo requests by grouping them by tags
   * It'll do one request for multiple items.
   *
   * Example HTML format:
   *
   * <div class="js-photo-marker"
   *     data-references="FINA_ATHLETE:234346"
   *     data-tags="athlete-image"
   *     data-group-by="tags">
   * </div>
   *
   * @constructor BatchImageHandler
   * @param {HTMLElement} container the element the widget manipulates/populates/affects
   */
  const BatchImageHandler = function () {
    this.requests = {};

    // listener for a new marker being created, triggers request logic
    document.body.addEventListener(NEW_MARKER_EVENT, _onNewRequest.bind(this));
  };
  BatchImageHandler.prototype.findMatchingPhotos = function (photoList, filter) {
    let groupBy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'tags';
    if (groupBy === 'tags' && (!filter.tags || filter.tags.length === 0) && groupBy === 'references' && (!filter.references || filter.references.length === 0)) {
      return [];
    }
    return photoList.filter(photo => {
      if (groupBy === 'tags') {
        return _matchesRule(photo, filter.references, contentHelper.hasReference);
      }
      return _matchesRule(photo, filter.tags, contentHelper.hasTag);
    });
  };

  /**
   * Callback for new photo marker being initialized and extracing a filter
   * It will interface with a batched request to retrieve the appropriate photo
   * @param  {CustomEvent} event - the custom event notification
   */
  const _onNewRequest = function (event) {
    const filterGroupId = event.detail.groupId;
    const filter = event.detail.filter;
    const groupBy = event.detail.groupBy;
    const contentType = event.detail.contentType;
    if (!this.requests[filterGroupId]) {
      this.requests[filterGroupId] = new app.common.BatchedRequest(filterGroupId, groupBy, contentType);
    }
    this.requests[filterGroupId].addItem(filter);
  };

  /**
   * Utility function that goes through the items to find within a photo and
   * returns whether they can be found, given a custom rule function that
   * determines whether the association exists
   * @param  {Object}   photo          - API photo response
   * @param  {Object[]} itemsToFind    - array of items to find
   * @param  {Function} hasAssociation - the rule
   * @return {Boolean}                 - if an assciation is found or not
   */
  const _matchesRule = (photo, itemsToFind, hasAssociation) => {
    for (let i = 0; i < itemsToFind.length; i++) {
      const itemToFind = itemsToFind[i];
      if (!hasAssociation(photo, itemToFind)) {
        return false;
      }
    }
    return true;
  };
  app.common.BatchImageHandler = new BatchImageHandler();
})(PULSE.app, PULSE.app.common.CONSTANTS, PULSE.app.common.content);
"use strict";

(function (app, CONSTANTS, core) {
  'use strict';

  const NEW_MARKER_EVENT = CONSTANTS.EVENTS.PHOTO_MARKER.WAITING;
  const NEW_PHOTOS_EVENT = CONSTANTS.EVENTS.PHOTO_MARKER.NEW_DATA;
  const PLACEHOLDER_TOGGLE_CLASS = 'has-placeholder';
  const ON_LOAD_CLASS = 'is-loaded';
  const FADED_IMAGE_SELECTOR = '.js-faded-image';
  const imageStore = {};

  /**
   * Abstract class - requires implementation
   *  - manages the interactions with the Batch Image Handler and Batched Request
   *  - handles the rendering & teardown of photos
   * @param {HTMLElement} container - the HTML container to render into
   * @param {Object}      config    - optional config
   */
  app.PhotoMarker = function PhotoMarker(container, config) {
    this.container = container;
    this.config = {
      groupId: config.groupId,
      groupBy: config.groupBy || container.getAttribute('data-group-by'),
      setSize: container.getAttribute('data-size'),
      filter: this.getFilter()
    };
    if (!this.configIsValid()) {
      console.warn('Attempted to start PhotoMarker with invalid config', container);
      return;
    }

    // hide the placeholder once the image is loaded into the DOM
    this.onImageLoad = function (event) {
      core.style.removeClass(this.container, PLACEHOLDER_TOGGLE_CLASS);
      const fadedImageEl = this.container.querySelector(FADED_IMAGE_SELECTOR);
      core.style.addClass(fadedImageEl, ON_LOAD_CLASS);
      event.target.removeEventListener('load', this.onImageLoad);
    }.bind(this);

    // if image has been rendered before on the page, we should have the HTML, so render it
    const storeId = this.getStoreId();
    if (imageStore[storeId]) {
      _publishImageFromStore.call(this, this.container, imageStore[storeId]);
      return;
    }

    /**
     * init-when-visible is used by the widgetInitialiser to only instantiate
     * widgets that are in view; if this has been initialised when not in view
     * then we can safely lazy-load it later
     * @type {Boolean}
     */
    this.useLazyLoad = container.getAttribute('data-init-when-visible') !== 'true';
    this.photoDataCallback = _onPhotoData.bind(this);
    // listener for photo data, that triggers the rendering
    document.body.addEventListener(NEW_PHOTOS_EVENT, this.photoDataCallback);
    if (this.useLazyLoad) {
      // render immediately
    } else {
      // widget's ready to receive photo data, trigger event
      app.common.fireEvent(NEW_MARKER_EVENT, {
        groupId: this.config.groupId,
        filter: this.config.filter,
        groupBy: this.config.groupBy
      });
    }
  };

  /**
   * Tear down so this instance can be garbage collected (remove the event listener)
   */
  app.PhotoMarker.prototype.teardown = function teardown() {
    document.body.removeEventListener(NEW_PHOTOS_EVENT, this.photoDataCallback);
  };

  /**
   * Abstract functions, must be implemented
   */

  /**
   * @abstact
   * Function that produces the filter object to send through to the BatchImageHandler
   */
  app.PhotoMarker.prototype.getFilter = function getFilter() {
    // eslint-disable-next-line new-cap
    throw new PULSE.unimplementedFunctionError('PhotoMarker#getFilter');
  };

  /**
   * @abstact
   * Function that checks if the config is valid
   */
  app.PhotoMarker.prototype.configIsValid = function configIsValid() {
    // eslint-disable-next-line new-cap
    throw new PULSE.unimplementedFunctionError('PhotoMarker#configIsValid');
  };

  /**
   * @abstact
   * Function that does the rendering (bespoke per implementation)
   * @param  {Object[]} photoData - array of photos that apply to this container
   */
  app.PhotoMarker.prototype.render = function render() {
    // eslint-disable-next-line new-cap
    throw new PULSE.unimplementedFunctionError('PhotoMarker#render');
  };

  /**
   * @abstact
   * Function that is run after render (bespoke per implementation)
   * @param  {Object[]} photoData - array of photos that apply to this container
   */
  app.PhotoMarker.prototype.postRender = function postRender() {
    // eslint-disable-next-line new-cap
    throw new PULSE.unimplementedFunctionError('PhotoMarker#postRender');
  };

  /**
   * @abstact
   * Function that generates a unique ID for the markup generated
   */
  app.PhotoMarker.prototype.getStoreId = function () {
    // eslint-disable-next-line new-cap
    throw new PULSE.unimplementedFunctionError('PhotoMarker#getStoreId');
  };

  /**
   * Private functions
   */

  /**
   * Given a stored bit of HTML, render the headshot from that; this also applies the logic that
   * would otherwise happen when dealing with the photo models
   * @param  {HTMLElement} container    - the main container
   * @param  {String}      headshotHtml - the string for the headshot
   */
  const _publishImageFromStore = function (container, headshotHtml) {
    // remove the placeholder
    core.style.removeClass(container, PLACEHOLDER_TOGGLE_CLASS);

    // render the HTML
    container.innerHTML = headshotHtml;
    this.postRender();
    const imageEl = container.querySelector(FADED_IMAGE_SELECTOR);
    if (imageEl.complete) {
      core.style.addClass(imageEl, ON_LOAD_CLASS);
    } else {
      imageEl.addEventListener('load', this.onImageLoad);
    }
  };

  /**
   * Executed when photo data comes back and the event is triggered
   * Goes through the data and extracts only the photos that are relevant to this
   * container, then sends them through to the renderer
   *
   * Will clean up after itself if the main container is no longer in the DOM
   * @param  {Event} event - event triggered
   */
  const _onPhotoData = function _onPhotoData(event) {
    if (this.config.groupId === event.detail.groupId && _requestMatchesFilter(event.detail.filter, this.config.filter, this.config.groupBy)) {
      const photoData = event.detail.data.content || [];

      // filter out any photos that don't match this marker
      const relevantPhotos = app.common.BatchImageHandler.findMatchingPhotos(photoData, this.config.filter, this.config.groupBy);
      if (relevantPhotos.length > 0) {
        this.render(relevantPhotos);
        this.postRender(relevantPhotos);
        imageStore[this.getStoreId()] = this.container.innerHTML;
        const imageEl = this.container.querySelector('img');
        if (imageEl) {
          imageEl.addEventListener('load', this.onImageLoad);
        }
        // once we've rendered the photo, tear down
        this.teardown();
      }
    }

    // if the container for this component is no longer in the DOM, tear down
    if (!document.body.contains(this.container)) {
      this.teardown();
    }
  };

  /**
   * Works out if the request that comes back has the player required
   * @param  {Object} requestFilter - the filter
   * @param  {Number} filter        -
   * @param  {String} groupBy       -
   * @return {Boolean}              - true if the player is in the filter, false otherwise
   */
  const _requestMatchesFilter = (requestFilter, filter, groupBy) => {
    let requestTerms = [];
    let filterTerms = [];
    if (groupBy === 'tags') {
      if (requestFilter.referenceExpression) {
        requestTerms = requestTerms.concat(requestFilter.referenceExpression.map(reference => {
          return `${reference.type}:${reference.id}`;
        }));
      }
      filterTerms = filter.references;
    } else {
      if (requestFilter.tagExpression) {
        requestTerms = requestTerms.concat(requestFilter.tagExpression);
      }
      filterTerms = filter.tags;
    }
    for (let i = 0; i < requestTerms.length; i++) {
      if (typeof filterTerms.find(term => requestTerms[i] === term) !== 'undefined') {
        return true;
      }
    }
    return false;
  };
})(PULSE.app, PULSE.app.common.CONSTANTS, PULSE.core);
"use strict";

(function (app, core, common) {
  'use strict';

  const {
    CLASSES
  } = common.CONSTANTS;
  const SELECTORS = {
    DRAWER: '.js-drawer',
    DRAWER_CONTENT: '.js-drawer-content'
  };
  app.AccordionWidget = class AccordionWidget {
    constructor(container) {
      this.container = container;
      this.drawers = this.container.querySelectorAll(SELECTORS.DRAWER);
      common.addMultiAriaClickListener(this.drawers, this.handleClick.bind(this));
      core.event.windowResize.add({
        method: this.handleResize.bind(this)
      });
    }

    /**
     * Hanle Click
     *
     * Handles the click event when a drawer button is clicked. Works out
     * if we should open/close the drawer and others if they're open.
     *
     * @param {Event} event - Click event object
     */
    handleClick(event) {
      const drawer = event.currentTarget;

      // Check if the current toggle is expanded.
      const isExpanded = drawer.getAttribute('aria-expanded') === 'true';

      // If not open already, open the drawer you clicked on
      if (!isExpanded) {
        this.openDrawer(drawer);
      } else {
        this.closeDrawer(drawer);
      }
      event.preventDefault();
    }

    /**
     * Handle Resize
     *
     * Callback for resize event, makes sure to update the height of any
     * open drawers, just incase things have changed.
     */
    handleResize() {
      const active = this.container.querySelector('[aria-expanded="true"]');
      if (active) {
        const activeContent = this.container.querySelector(`#${active.getAttribute('aria-controls')}`);
        if (activeContent.children && activeContent.children[0]) {
          activeContent.style.height = `${activeContent.children[0].offsetHeight}px`;
        }
      }
    }

    /**
     * Open Drawer
     *
     * Does everything required to open a drawer, pass it the button
     * element for the drawer you want to open.
     *
     * @param {HTMLElement} drawer - The button of the drawer to open.
     */
    openDrawer(drawer) {
      core.style.addClass(drawer, CLASSES.IS_OPEN);
      drawer.setAttribute('aria-expanded', 'true');
      drawer.setAttribute('data-expanded', 'true');
      const drawerContent = this.container.querySelector(`#${drawer.getAttribute('aria-controls')}`);
      if (drawerContent.children && drawerContent.children[0]) {
        drawerContent.style.height = `${drawerContent.children[0].offsetHeight}px`;
      }
    }

    /**
     * Close Drawer
     *
     * Does everything required to close a drawer, pass it the button
     * element for the drawer you want to close.
     *
     * @param {HTMLElement} drawer - The button of the drawer to close.
     */
    closeDrawer(drawer) {
      core.style.removeClass(drawer, CLASSES.IS_OPEN);
      drawer.setAttribute('aria-expanded', 'false');
      drawer.setAttribute('data-expanded', 'false');
      const drawerContent = this.container.querySelector(`#${drawer.getAttribute('aria-controls')}`);
      if (drawerContent.children && drawerContent.children[0]) {
        drawerContent.style.height = '';
      }
    }
  };
  app.widgetInitialiser.addMultipleWidgetsByName('accordion', app.AccordionWidget);
})(PULSE.app, PULSE.core, PULSE.app.common);
"use strict";

(function (common) {
  /**
   * Checks validity of an entire config object based on given checks
   * @param {string} constructorName the namespace of the constructor calling this method
   * @param {Object} config the full config object to be validated
   * @param {Object[]} checks the array of checks to be run against the config object
   * @param {string} checks[].namespace the namespace of the config property to be checked
   * @param {string} [checks[].type] the type of config check if not a simple exists check - HTMLElement, NodeList
   * @param {string} [checks[].selector] the selector to use when looking for element/s
   * @param {string} [checks[].default] the default value to be applied if check fails
   * @returns {Object} returns updated config
   */
  common.configChecker = function (constructorName) {
    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let checks = arguments.length > 2 ? arguments[2] : undefined;
    const errors = [];
    checks.forEach(function (check) {
      if (!config[check.namespace]) {
        switch (check.type) {
          case 'HTMLElement':
            if (config.container && check.selector) {
              config[check.namespace] = config.container.querySelector(check.selector);
              if (!config[check.namespace]) {
                errors.push('missing config.' + check.namespace + ", cannot find an element with the selector '" + check.selector + "'");
              }
            } else {
              errors.push('missing config.' + check.namespace);
            }
            break;
          case 'NodeList':
            if (config.container && check.selector) {
              config[check.namespace] = config.container.querySelectorAll(check.selector);
              if (config[check.namespace].length < 1) {
                errors.push('missing config.' + check.namespace + ", cannot find any elements with the selector '" + check.selector + "'");
              }
            } else {
              errors.push('missing config.' + check.namespace);
            }
            break;
          default:
            if (!check.default) {
              errors.push('missing config.' + check.namespace);
            } else {
              config[check.namespace] = check.default;
            }
        }
      }
    });
    if (errors.length > 0) {
      errors.unshift('You have ' + errors.length + ' errors initialising ' + constructorName);
      return null;
    }
    return config;
  };
})(PULSE.app.common);
"use strict";

(function (app, core, widgetHelper, contentHelper, imageHelper) {
  'use strict';

  app.AthleteHeadshotWidget = function AthleteHeadshotWidget(container) {
    app.PhotoMarker.call(this, container, {
      groupBy: 'tags',
      groupId: 'athlete-headshot-handling'
    });
  };
  app.AthleteHeadshotWidget.prototype = Object.create(app.PhotoMarker.prototype);
  app.AthleteHeadshotWidget.prototype.constructor = app.AthleteHeadshotWidget;

  /**
   * Checks that the config is correct and the filter was retrieved
   * @return {Boolean} true if correct, false otherwise
   */
  app.AthleteHeadshotWidget.prototype.configIsValid = function configIsValid() {
    if (!this.config.groupBy && (this.filter.tags || this.filter.references)) {
      return false;
    }
    if (typeof HEADSHOT_SIZES[this.config.setSize] === 'undefined') {
      console.warn('AthleteHeadshotWidget size unrecognised; cannot render', this.container);
      return false;
    }
    return true;
  };

  /**
   * Generates the filter object of tags & content referneces to retrieve the
   * player image that is required to generate the markup
   * @return {Object} the filter
   */
  app.AthleteHeadshotWidget.prototype.getFilter = function getFilter() {
    this.athleteId = widgetHelper.getNumberAttribute('data-athlete-id', this.container);
    if (this.athleteId && !isNaN(this.athleteId)) {
      return {
        tags: ['athlete-image'],
        references: [`FINA_ATHLETE:${this.athleteId}`]
      };
    }
    return {};
  };

  /**
   * Render the markup
   * @param  {Object[]} photoData - array of photos that apply to this container
   */
  app.AthleteHeadshotWidget.prototype.render = function render(photoData) {
    const latestHeadshot = photoData[0];
    if (latestHeadshot) {
      const idealMediaQuerySet = HEADSHOT_SIZES[this.config.setSize];
      const mediaQuerySizes = imageHelper.getMediaQuerySet(latestHeadshot, idealMediaQuerySet);
      const photoModel = contentHelper.getContentModel(latestHeadshot, mediaQuerySizes);

      // render and store in case we need it on the same page again
      this.container.innerHTML = app.templating.render({
        title: latestHeadshot.title,
        cssClass: '',
        mediaQueryConfig: photoModel.mediaQueryConfig,
        objectFit: this.container.getAttribute('data-object-fit') === 'true',
        fadeInOnLoad: true
      }, 'common.picture-element');
    }
  };

  /**
   * Add modifiers based on the image rendered
   */
  app.AthleteHeadshotWidget.prototype.postRender = function postRender() {
    core.style.addClass(this.container.parentElement, 'is-loaded');
    return;
  };

  /**
   * Unique identifier for a player's photo, based on the player ID & the requested size
   * @return {String} - the identifier
   */
  app.AthleteHeadshotWidget.prototype.getStoreId = function () {
    return `${this.config.groupId}_${this.config.setSize}_${this.athleteId}`;
  };
  const HEADSHOT_SIZES = {
    TABLE: [
    // image in table
    {
      name: 'all',
      minWidth: 1,
      size: {
        width: 80
      },
      multipliers: [1, 2] // eslint-disable-line no-magic-numbers
    }, {
      name: 'default',
      size: {
        width: 80
      },
      cssClass: 'athlete-headshot__image',
      multipliers: [1]
    }],
    CARD: [
    // image in card (records)
    {
      name: 'mobile',
      maxWidth: app.measurements.tablet,
      size: {
        width: 80
      },
      multipliers: [1, 2] // eslint-disable-line no-magic-numbers
    }, {
      name: 'desktop',
      minWidth: app.measurements.tablet,
      size: {
        width: 120
      },
      multipliers: [1, 2] // eslint-disable-line no-magic-numbers
    }, {
      name: 'default',
      size: {
        width: 120
      },
      cssClass: 'athlete-headshot__image',
      multipliers: [1]
    }]
  };
  app.widgetInitialiser.addMultipleWidgetsByName('athlete-image');
})(PULSE.app, PULSE.core, PULSE.app.common.widget, PULSE.app.common.content, PULSE.app.common.image);
"use strict";

(function (app, core, widgetHelper, contentHelper, imageHelper) {
  'use strict';

  app.CompetitionLogoWidget = function CompetitionLogoWidget(container) {
    app.PhotoMarker.call(this, container, {
      groupBy: 'tags',
      groupId: 'competition-logo-handling'
    });
  };
  app.CompetitionLogoWidget.prototype = Object.create(app.PhotoMarker.prototype);
  app.CompetitionLogoWidget.prototype.constructor = app.CompetitionLogoWidget;

  /**
   * Checks that the config is correct and the filter was retrieved
   * @return {Boolean} true if correct, false otherwise
   */
  app.CompetitionLogoWidget.prototype.configIsValid = function configIsValid() {
    if (!this.config.groupBy && (this.filter.tags || this.filter.references)) {
      return false;
    }
    if (typeof LOGO_SIZES[this.config.setSize] === 'undefined') {
      console.warn('CompetitionLogoWidget size unrecognised; cannot render', this.container);
      return false;
    }
    return true;
  };

  /**
   * Generates the filter object of tags & content referneces to retrieve the
   * player image that is required to generate the markup
   * @return {Object} the filter
   */
  app.CompetitionLogoWidget.prototype.getFilter = function getFilter() {
    this.competitionId = widgetHelper.getNumberAttribute('data-comp-id', this.container);
    const tag = this.container.getAttribute('data-tag') || 'competition-logo';
    const referenceKey = this.container.getAttribute('data-ref-key') || 'FINA_COMPETITION';
    if (this.competitionId && !isNaN(this.competitionId)) {
      return {
        tags: [tag],
        references: [`${referenceKey}:${this.competitionId}`]
      };
    }
    return {};
  };

  /**
   * Render the markup
   * @param  {Object[]} photoData - array of photos that apply to this container
   */
  app.CompetitionLogoWidget.prototype.render = function render(photoData) {
    const latestLogo = photoData[0];
    if (latestLogo) {
      const idealMediaQuerySet = LOGO_SIZES[this.config.setSize];
      const mediaQuerySizes = imageHelper.getMediaQuerySet(latestLogo, idealMediaQuerySet);
      const photoModel = contentHelper.getContentModel(latestLogo, mediaQuerySizes);

      // render and store in case we need it on the same page again
      this.container.innerHTML = app.templating.render({
        title: latestLogo.title,
        cssClass: '',
        imageCssClass: 'object-fit-cover-picture__img--contain',
        mediaQueryConfig: photoModel.mediaQueryConfig,
        objectFit: this.container.getAttribute('data-object-fit') === 'true',
        fadeInOnLoad: true
      }, 'common.picture-element');
    }
  };

  /**
   * Add modifiers based on the image rendered
   */
  app.CompetitionLogoWidget.prototype.postRender = function postRender() {
    core.style.addClass(this.container.parentElement, 'is-loaded');
    return;
  };

  /**
   * Unique identifier for a player's photo, based on the player ID & the requested size
   * @return {String} - the identifier
   */
  app.CompetitionLogoWidget.prototype.getStoreId = function () {
    return `${this.config.groupId}_${this.config.setSize}_${this.competitionId}`;
  };
  const LOGO_SIZES = {
    SMALL: [
    // comp list
    {
      name: 'tablet',
      maxWidth: app.measurements.tablet,
      size: {
        width: 126
      },
      multipliers: [1, 2] // eslint-disable-line no-magic-numbers
    }, {
      name: 'desktop',
      minWidth: app.measurements.tablet,
      size: {
        width: 200
      },
      multipliers: [1, 2] // eslint-disable-line no-magic-numbers
    }, {
      name: 'default',
      size: {
        width: 200
      },
      multipliers: [1],
      cssClass: ''
    }]
  };
  app.widgetInitialiser.addMultipleWidgetsByName('competition-logo');
})(PULSE.app, PULSE.core, PULSE.app.common.widget, PULSE.app.common.content, PULSE.app.common.image);
"use strict";

(function (app, core) {
  'use strict';

  const OBSERVER_CONFIG = {
    root: null,
    // default to browser viewport
    rootMargin: '0px',
    threshold: 0.025
  };
  const OBSERVABLE_SELECTOR = '.js-lazy-load';

  /**
   * Class that loads in images when they become active
   * upon entering the viewport
   *
   * @param {HTMLElement} container the container element of the items that should be observed
   * @constructor
   */
  app.LazyLoad = function (container) {
    const _self = this;
    const observableContainers = [].slice.call(container.querySelectorAll(OBSERVABLE_SELECTOR));

    // get items unobserved and apply the listeners
    const uninitiatedObservables = _self.getUnobservedElements(observableContainers);
    _self.setObservableListener(uninitiatedObservables);
  };

  /**
   * Filters the observableContainer list so the items being observed have not been observed before
   * and are the correct markup elements for observing
   *
   * @param {HTMLElement[]} observableContainers - the matching elements that are meant to be observed
   * @return {Array} Filtered array of observable elements
   */
  app.LazyLoad.prototype.getUnobservedElements = function getUnobservedElements(observableContainers) {
    return observableContainers.filter(observableEl => {
      return observableEl && observableEl.getAttribute('data-picture-in-view') !== 'true';
    });
  };

  /**
   * Listens for elements to become visible within the viewport
   *
   * @param {HTMLElement[]} observableContainers - the matching elements to apply observer listeners to
   */
  app.LazyLoad.prototype.setObservableListener = function setOberservableListener(observableContainers) {
    const _self = this;
    _self.observer = new IntersectionObserver(_onActivate, OBSERVER_CONFIG);
    observableContainers.forEach(element => {
      _self.observer.observe(element);
    });
  };

  /**
   * Callback function from intersection observer
   *
   * `getAttribute` has been used deliberately as it tested faster than
   * `element.dataset.attrName`.
   *
   * @param  {Object[]} entries An Array of IntersectionObserver elements
   */
  const _onActivate = entries => {
    entries.forEach(contentItem => {
      let imgContainer = contentItem.target;
      if (!imgContainer) {
        return;
      }

      // check if the intersection observer's already run on this element
      let hasIntersectedBefore = imgContainer.getAttribute('data-picture-in-view');
      if (contentItem.isIntersecting === false || hasIntersectedBefore === 'true') {
        return;
      }

      // Picture is now in view so add this attr to stop it rendering again.
      imgContainer.setAttribute('data-picture-in-view', 'true');

      // get the picture element/image markup from the comment and add it to the container
      const imageComment = _getFirstCommentNodeChild(imgContainer);
      if (imageComment) {
        imgContainer.insertAdjacentHTML('beforeend', imageComment.textContent.trim());
      }

      // fade in the image (if needed - only js-faded-image marked elements need this)
      let fadedImage = imgContainer.querySelector('.js-faded-image');
      if (fadedImage) {
        if (fadedImage.complete) {
          _fadeElementIn(fadedImage, imgContainer);
        } else {
          // only add load listener if the image hasn't been loaded already
          fadedImage.addEventListener('load', function () {
            _fadeElementIn(fadedImage, imgContainer);
          });
        }
      }
    });
  };
  const _fadeElementIn = function _fadeElementIn(fadedImage, imgContainer) {
    core.style.addClass(fadedImage, 'is-loaded');
    core.style.addClass(imgContainer, 'is-loaded');
  };

  /**
   * Returns the first comment node child of an element
   * @param  {HTMLElement} element - the html element to search the child nodes for
   * @return {(Comment|null)}      - the 1st comment node found, or null
   */
  const _getFirstCommentNodeChild = function _getFirstCommentNodeChild(element) {
    for (let i = 0; i < element.childNodes.length; i++) {
      if (element.childNodes[i].nodeType === Node.COMMENT_NODE) {
        return element.childNodes[i];
      }
    }
    return null;
  };
  app.widgetInitialiser.addMultipleWidgetsByName('lazy-load-images', app.LazyLoad);
})(PULSE.app, PULSE.core);
"use strict";

(function (common) {
  'use strict';

  let errors = [];

  /**
   * Validates config object based on passed tests
   *
   * @param {string} constructorName - the namespace of the constructor calling this method
   * @param {Object} config - the full config object to be validated
   * @param {Object[]} tests - the array of tests to be run against the config object
   * @param {string} tests[].namespace - The name of the property in the configuration object
   * @param {string} [tests[].selector] - Use if the property should be assigned a DOMElement. Any CSS selector.
   * @param {string} [tests[].elementType] - What interface should the DOMElement be? E.g. NodeList, HTMLElement
   * @returns {Boolean} - True if config was valid
   *
   * Example Tests Object
   *
   * tests = [
   *      {
   *          namespace: 'container',
   *          elementType: HTMLElement
   *      },
   *      {
   *          namespace: 'elements',
   *          elementType: NodeList
   *      },
   *
   * ]
   */
  common.validateConfig = function validateConfig(constructorName) {
    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let tests = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    tests.forEach(testCase => {
      // Does the namespace exist?
      namespaceExists(testCase, config);
      // Does the element exist ?
      elementExists(testCase, config);
      // Is the element the correct type?
      correctType(config[testCase.namespace], testCase);
    });
    if (errors.length > 0) {
      errors.unshift(`You have ${errors.length} errors initialising ${constructorName}.`);
      console.warn(errors.join('\n'));
      return false;
    }
    return true;
  };
  const namespaceExists = (testCase, config) => {
    if (config[testCase.namespace]) {
      return true;
    }
    errors.push(`Missing configuration property. config.${testCase.namespace} is required and should be of type ${testCase.elementType}`);
    return false;
  };
  const elementExists = (testCase, config) => {
    if (typeof testCase.namespace === 'undefined' || testCase.elementType === 'undefined') {
      return;
    }
    let element = config[testCase.namespace];
    if (typeof element !== 'object') {
      errors.push(`Could not find ${testCase.elementType.name} under config.${testCase.namespace}`);
      return;
    }
    if (typeof element.length !== 'undefined' && element.length === 0) {
      errors.push(`Empty ${testCase.elementType.name} under config.${testCase.namespace}`);
      return;
    }
  };
  const correctType = (element, testCase) => {
    if (typeof element === 'undefined') {
      return;
    }
    if (!(element instanceof testCase.elementType)) {
      errors.push(`Incorrect type. Expected config.${testCase.namespace} to be instance of ${testCase.elementType.name}`);
    }
  };
})(PULSE.app.common);
"use strict";

(function (core, common) {
  common.filterOptions = function filterOptions(filters, references) {
    const _self = this;
    _self.filters = filters;
    _self.updateReferences(references);
  };
  common.filterOptions.prototype.addRefsToFilters = function addRefsToFilters() {
    const _self = this;
    let refString = '';
    if (typeof _self.references === 'string') {
      refString += _self.references;
    } else {
      for (var key in _self.references) {
        // skip loop if the property is from prototype
        if (!_self.references.hasOwnProperty(key)) {
          continue;
        }
        if (refString.length > 0) {
          refString += ',';
        }
        refString += key + ':' + _self.references[key];
      }
    }
    _self.filters.references = refString;
  };
  common.filterOptions.prototype.updateFilters = function updateFilters(newFilters) {
    const _self = this;
    _self.filters = core.object.extend(_self.filters, newFilters);
  };
  common.filterOptions.prototype.updateReferences = function updateReferences(newReferences) {
    const _self = this;
    if (typeof newReferences !== 'undefined') {
      if (!_self.references || typeof _self.references === 'string') {
        _self.references = newReferences;
      } else {
        _self.references = core.object.extend(_self.references, newReferences);
      }
      _self.addRefsToFilters();
    }
  };
  common.filterOptions.prototype.removeReference = function removeReference(reference) {
    const _self = this;
    delete _self.references[reference];
    _self.addRefsToFilters();
  };
  common.filterOptions.prototype.get = function get() {
    const _self = this;
    return _self.filters;
  };
})(PULSE.core, PULSE.app.common);
"use strict";

(function (app, core, common) {
  'use strict';

  const YEAR = 365;
  const COOKIE_EXPIRY = YEAR * 2; // 2 years as days

  /**
   * Shows the cookie notice banner if the user has not made a decision on cookies
   */
  const checkCookieOnLoad = () => {
    //Check in set cookies to see if cookie policy has been chosen
    const cookiePolicyChosen = core.localStorage.getStorage('cookie-policy-chosen', true);
    if (!cookiePolicyChosen || cookiePolicyChosen !== 'true') {
      displayCookieNotice();
    }
  };

  /**
   * Query DOM for the cookie notice banner then display it
   * Also adds event listeners to the user input buttons
   */
  const displayCookieNotice = () => {
    const privacyMessage = document.getElementById('js-cookie-notice');

    //Set a temporary value of agreeing to essential cookies to be overwritten by the user
    core.localStorage.setStorage('only-essential-cookies', true);

    //Add event listener to all buttons
    const cookieButtons = document.querySelectorAll('.js-cookie-notice-btn');
    cookieButtons.forEach(function (button) {
      button.addEventListener('click', common.setCookies);
    });
    if (privacyMessage) {
      core.style.removeClass(privacyMessage, 'u-hide');
    }
  };

  /**
   * Updating local storage value with user's decision.
   * @param {object} [event] the click event from the button which determines the user's decision
   */
  common.setCookies = event => {
    const hostname = document.location.hostname;
    const privacyMessage = document.getElementById('js-cookie-notice');

    // Updates local storage based on user's decision
    const allCookies = event.currentTarget.dataset.acceptAllCookies;
    const updateStorage = decision => {
      core.localStorage.setStorage('only-essential-cookies', decision);
      core.localStorage.setStorage('cookie-policy-chosen', true, COOKIE_EXPIRY, true, hostname);
    };

    //Logic to determine user's decision and calls update storage with their decision
    if (allCookies === 'true') {
      updateStorage(false);
      const cookiesAccepted = new CustomEvent('cookiesAccepted', {
        detail: 'all'
      });
      window.dispatchEvent(cookiesAccepted);
    } else if (allCookies === 'false') {
      updateStorage(true);
      const cookiesAccepted = new CustomEvent('cookiesAccepted', {
        detail: 'essential'
      });
      window.dispatchEvent(cookiesAccepted);
    }
    core.style.addClass(privacyMessage, 'u-hide');
  };
  checkCookieOnLoad();
})(PULSE.app, PULSE.core, PULSE.app.common);
"use strict";

(function (app, common, core) {
  'use strict';

  const MOBILE_NAV = '.js-desktop-nav';
  const DROPDOWN_BUTTON = 'js-dropdown-btn';
  const OPEN_CLASS = 'is-open';
  app.DesktopNavigation = function (container) {
    this.container = container;
    this.list = container.querySelector(MOBILE_NAV);
    common.addAriaClickListener(this.container, this.delegateEvent.bind(this));
  };
  app.DesktopNavigation.prototype.delegateEvent = function delegateEvent(event) {
    if (event.target.classList.contains(DROPDOWN_BUTTON)) {
      core.style.toggleClass(event.target, OPEN_CLASS);
      const openDropdowns = [].slice.call(this.list.querySelectorAll(`.${DROPDOWN_BUTTON} + .${OPEN_CLASS}`));
      this.closeDropdown(openDropdowns);
      this.toggleDropdown(event.target.nextElementSibling);
      common.addAriaClickListener(document.body, this.autoCloseDropdown.bind(this), false, false, true);
    }
  };
  app.DesktopNavigation.prototype.closeDropdown = function doDropdown(openDropdowns) {
    for (let i = 0; i < openDropdowns.length; i++) {
      if (openDropdowns[i].previousElementSibling === event.target) {
        continue;
      }
      openDropdowns[i].previousElementSibling.classList.remove(OPEN_CLASS);
      openDropdowns[i].classList.remove(OPEN_CLASS);
      openDropdowns[i].setAttribute('aria-expanded', false);
      openDropdowns[i].setAttribute('aria-hidden', true);
    }
  };
  app.DesktopNavigation.prototype.autoCloseDropdown = function autoCloseDropdown(event) {
    const insideNav = event.target.closest(MOBILE_NAV);
    if (!insideNav) {
      const openDropdowns = [].slice.call(this.list.querySelectorAll(`.${DROPDOWN_BUTTON} + .${OPEN_CLASS}`));
      this.closeDropdown(openDropdowns);
      common.removeAriaClickListener(document.body, this.autoCloseDropdown.bind(this));
    }
  };
  app.DesktopNavigation.prototype.toggleDropdown = function toggleDropdown(dropdown) {
    core.style.toggleClass(dropdown, OPEN_CLASS);
    dropdown.getAttribute('aria-expanded') === 'true' ? dropdown.setAttribute('aria-expanded', false) : dropdown.setAttribute('aria-expanded', true);
    dropdown.getAttribute('aria-hidden') === 'true' ? dropdown.setAttribute('aria-hidden', false) : dropdown.setAttribute('aria-hidden', true);
  };
  app.widgetInitialiser.addMultipleWidgetsByName('desktop-navigation', app.DesktopNavigation);
})(PULSE.app, PULSE.app.common, PULSE.core);
"use strict";

(function (app, core) {
  'use strict';

  const ITEM_SELECTOR = '.js-dynamic-child';
  const LIST_SELECTOR = '.js-dynamic-list';
  const BUCKET_SELECTOR = '.js-dynamic-more-bucket';
  const GHOST_CLASS = 'dynamic-more__ghost';
  const HIDE_CLASS = 'u-hide';
  const TEMPLATE = 'common.dynamic-more';

  /**
   * Dynamic More
   *
   * Add dynamic 'More' list item to linked-list components ( automatically
   * constructed when `linkedList` freemarker macro is passed
   * `dynamicMore=true` argument.
   *
   * @param { HTMLElement } container - the element the widget is attached to.
   * @param {String} [template=null] - the template to use
   */
  app.DynamicMore = function (container) {
    let template = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const _self = this;
    _self.container = container;
    _self.list = container.querySelector(LIST_SELECTOR);
    _self.list.style.position = 'relative';
    _self.items = container.querySelectorAll(ITEM_SELECTOR);
    _self.more = null;
    _self.template = template || TEMPLATE;
    _self.componentClass = container.getAttribute('data-component-class');
    this.initialised = false;
    this.mql = window.matchMedia(`(max-width: ${app.measurements.tablet}px)`);
    if (this.mql.matches) {
      core.event.windowResize.add({
        method: onResize.bind(this)
      });
      return;
    }
    init.call(this);
  };

  /**
   * On Resize
   *
   * Callback that is hooked up if the window is too small to init the more
   * straight away. Fires on window resize and checks if the window is big
   * enough and if we've already been initialised.
   */
  const onResize = function onResize() {
    if (!this.mql.matches && !this.initialised) {
      init.call(this);
    }
  };

  /**
   * Init
   *
   * Kicks of the dynamic more by scaffolding the more button and setting up
   * the intersection observer.
   */
  const init = function init() {
    this.initialised = true;
    this.bucket = scaffold.call(this, this.list);
    const config = {
      root: this.list,
      rootMargin: `0px -${this.more.clientWidth}px 0px 0px`,
      threshold: 1
    };
    const observer = new IntersectionObserver(handler.bind(this), config);
    this.items.forEach(item => observer.observe(item));
  };

  /**
   * Handler
   *
   * Is the intersection observer callback. Will determine items that are
   * entering/exiting the viewport and execute logic accordingly.
   *
   * @param { Array } items - array of observed items that have changed.
   */
  const handler = function handler(items) {
    if (!items[0].rootBounds.right || this.mql.matches) {
      return;
    }
    const _self = this;
    const sortedItems = items.reduce(groupItems, {
      exiting: [],
      entering: []
    });
    sortedItems.exiting.forEach(exit.bind(_self));
    sortedItems.entering.forEach(enter.bind(_self));
    const children = _self.bucket.children.length;
    if (children) {
      _self.more.classList.remove(HIDE_CLASS);
    } else {
      _self.more.classList.add(HIDE_CLASS);
    }
  };

  /**
   * Scaffold
   *
   * Will scaffold the DOM, creating the `more` `linked-list__item`.
   *
   * @param { HTMLElement } container - the container we want to append the `more` item to.
   * @returns { HTMLElement } the element selected by `BUCKET_SELECTOR`.
   */
  const scaffold = function scaffold(container) {
    const _self = this;
    const element = app.templating.render({
      componentClass: _self.componentClass
    }, _self.template, true);
    _self.more = container.appendChild(element);
    return container.querySelector(BUCKET_SELECTOR);
  };

  /**
   * Group Items
   *
   * Should be used in a `reduce`. Job is to group items into `exiting` and
   * `entering` objects.
   *
   * @param { Object } collection - the reduced collection.
   * @param { Object } collection.exiting - the items that are exiting the container
   * @param { Object } collection.entering - the items that are entering the container
   * @param { Object } item - the observed (intersection observer) item
   * @returns { Object } collection - the reduced collection
   */
  const groupItems = (collection, item) => {
    if (item.boundingClientRect.right >= item.rootBounds.right) {
      collection.exiting.unshift(item);
    } else {
      collection.entering.push(item);
    }
    return collection;
  };

  /**
   * Exit
   *
   * Called on item that is exiting viewport.
   *
   * @param { Object } item - the observed item.
   */
  const exit = function exit(item) {
    const _self = this;
    if (getComputedStyle(item.target, null).display === 'none') {
      return;
    }
    item.target.setAttribute('data-cloned', Date.now());
    const clone = item.target.cloneNode(true);
    _self.bucket.prepend(clone);
    item.target.classList.add(GHOST_CLASS);
    item.target.style.left = `${item.boundingClientRect.left - item.rootBounds.left}px`;
  };

  /**
   * Enter
   *
   * Called on item that is entering viewport.
   *
   * @param { Object } item - the observed item.
   */
  const enter = function enter(item) {
    const _self = this;
    const clone = _self.bucket.querySelector(`[data-cloned="${item.target.getAttribute('data-cloned')}"]`);
    if (!clone) {
      return;
    }
    clone.remove();
    item.target.classList.remove(GHOST_CLASS);
    item.target.removeAttribute('data-cloned');
    item.target.style.left = '0';
  };
  app.widgetInitialiser.addMultipleWidgetsByName('dynamic-more', app.DynamicMore);
})(PULSE.app, PULSE.core);
"use strict";

(function (app, common, core) {
  'use strict';

  const MOBILE_NAV = '.js-mobile-nav';
  const MOBILE_NAV_BUTTON = 'js-mobile-nav-btn';
  const DROPDOWN_BUTTON = 'js-dropdown-btn';
  const DROPDOWN_OPEN_CLASS = 'dropdown-is-open';
  const OPEN_CLASS = 'is-open';
  const ACTIVE_CLASS = 'is-active';
  const DROPDOWN_BACK_BUTTON = 'js-back-btn';
  const BODY_CLASS_OPEN = 'mobile-nav-open';
  app.MobileNavigation = function (container) {
    const _self = this;
    _self.container = container;
    _self.list = container.querySelector(MOBILE_NAV);
    _self.button = container.querySelector(`.${MOBILE_NAV_BUTTON}`);
    _self.body = document.body;

    // common.addAriaClickListener( _self.button, _self.toggleMenu.bind( _self ) );
    common.addAriaClickListener(_self.container, _self.delegateEvent.bind(_self));
  };
  app.MobileNavigation.prototype.delegateEvent = function delegateEvent(event) {
    const _self = this;
    if (event.target.classList.contains(MOBILE_NAV_BUTTON)) {
      _self.toggleMenu();
    }
    if (event.target.classList.contains(DROPDOWN_BACK_BUTTON)) {
      _self.toggleDropdown(event.target.parentElement);
    }
    if (event.target.classList.contains(DROPDOWN_BUTTON)) {
      let openDropdowns = _self.list.querySelectorAll(`.${DROPDOWN_BUTTON} + .${OPEN_CLASS}`);
      [].slice.call(openDropdowns, _self.toggleDropdown);
      _self.toggleDropdown(event.target.nextElementSibling);
    }
  };
  app.MobileNavigation.prototype.toggleMenu = function toggleMenu() {
    const _self = this;
    core.style.toggleClass(_self.list, OPEN_CLASS);
    core.style.toggleClass(_self.button, ACTIVE_CLASS);
    core.style.toggleClass(_self.body, BODY_CLASS_OPEN);
    common.bodyScroll.toggle();
  };
  app.MobileNavigation.prototype.toggleDropdown = function toggleDropdown(dropdown) {
    const _self = this;
    core.style.toggleClass(dropdown, OPEN_CLASS);
    dropdown.getAttribute('aria-expanded') === 'true' ? dropdown.setAttribute('aria-expanded', false) : dropdown.setAttribute('aria-expanded', true);
    dropdown.getAttribute('aria-hidden') === 'true' ? dropdown.setAttribute('aria-hidden', false) : dropdown.setAttribute('aria-hidden', true);
    let openDropdowns = _self.list.querySelectorAll(`.${DROPDOWN_BUTTON} + .${OPEN_CLASS}`);
    if (!openDropdowns.length) {
      core.style.removeClass(_self.list, DROPDOWN_OPEN_CLASS);
      return;
    }
    core.style.addClass(_self.list, DROPDOWN_OPEN_CLASS);
  };
  app.widgetInitialiser.addMultipleWidgetsByName('mobile-navigation', app.MobileNavigation);
})(PULSE.app, PULSE.app.common, PULSE.core);
"use strict";

(function (app, common, core) {
  const scheduleStore = {};
  const ScheduleRequester = class ScheduleRequester {
    /**
    * ScheduleRequester
    */
    constructor() {
      this.requestQue = {};
    }

    /**
     * Get
     *
     * Get a schedule, first checks the store, then sees if there is already
     * a request for it, then sets up a new request if not.
     *
     * @param {String} compId - The competition Id
     * @param {Function} callback - A function to run when this schedule is recieved
     */
    get(compId, callback) {
      if (!compId || typeof callback !== 'function') {
        console.error('[ScheduleRequester] - Incorrect params passed to add( compId, callback )');
        return;
      }
      const storedSchedule = scheduleStore[compId];
      if (storedSchedule) {
        callback(storedSchedule);
        return;
      }

      // Add callback to Que if it's already being requested
      if (this.requestQue[compId]) {
        this.requestQue[compId].push(callback);
        return;
      }

      // Start new Que and kick-off request
      this.requestQue[compId] = [callback];
      const url = common.endpoints.fina.competitions.schedule(compId);
      core.data.request(url, 'GET', data => {
        this.handleScheduleResponse(compId, data);
      }, [app.account]);
    }

    /**
     * Handle Schedule Response
     *
     * Once a schedule returns, add it to the store for later requests and
     * run all the callbacks added to its que.
     *
     * @param {String} compId - The competition Id
     * @param {Array} data - The response from the schedule api
     */
    handleScheduleResponse(compId, data) {
      scheduleStore[compId] = data;
      if (this.requestQue[compId] && this.requestQue[compId].length) {
        for (let i = 0, length = this.requestQue[compId].length; i < length; i++) {
          const callback = this.requestQue[compId][i];
          callback(data);
        }
      }
    }
  };
  app.common.ScheduleRequester = new ScheduleRequester();
})(PULSE.app, PULSE.app.common, PULSE.core);
"use strict";

(function (app, common, core) {
  app.SeasonDatesWidget = class SeasonDates {
    /**
    * SeasonDates
    *
    * @param { HTMLElement } container - container Element that widget is instantiated on
    */
    constructor(container) {
      this.container = container;
      this.compId = this.container.getAttribute('data-comp');
      this.monthDate = this.container.getAttribute('data-month-date');
      app.common.ScheduleRequester.get(this.compId, this.handleSchedule.bind(this));
    }

    /**
     * Handle Schedule
     *
     * Callback for when the schedule arrives. Looks at the events in the
     * schedule to determine what dates events happened on, in this month.
     * Then formats and renders them.
     *
     * @param {Array} schedule - Response from the schedule api
     */
    handleSchedule(schedule) {
      // if no schedule or it's empty, use fallback
      if (!schedule || !Array.isArray(schedule) || schedule.length === 0) {
        const dateFrom = this.container.getAttribute('data-from');
        const dateTo = this.container.getAttribute('data-to');
        this.container.innerHTML = common.date.formatCompDates(dateFrom, dateTo);
        return;
      }

      // Filter out only the events that occured in this month
      const eventsInMonth = schedule.filter(scheduleEvent => dayjs(scheduleEvent.Date).isSame(this.monthDate, 'month'));

      // Grab all the unique dates
      const uniqueDates = eventsInMonth.reduce((dates, scheduleEvent) => {
        const eventDate = dayjs(scheduleEvent.Date).format('MMM DD');
        if (!dates.includes(eventDate)) {
          dates.push(eventDate);
        }
        return dates;
      }, []);

      // Grab the wrapping LI and OL elements to handle sorting and removing if neccesary
      this.itemListEle = common.dom.closest(this.container, '.js-item-list');
      this.itemEle = common.dom.closest(this.container, '.js-item');

      // If there are no events in this month, remove it from the calendar
      if (!uniqueDates || !uniqueDates.length) {
        this.itemListEle.removeChild(this.itemEle);

        // If it was the last item in the month, remove list and month header
        if (this.itemListEle.children.length === 0) {
          this.itemListEle.parentElement.removeChild(this.itemListEle.previousElementSibling);
          this.itemListEle.parentElement.removeChild(this.itemListEle);
        }
        return;
      }

      // Add from attribute with first event date for sorting
      this.itemFirstDate = dayjs(eventsInMonth[0].Date);
      this.itemEle.setAttribute('data-from', this.itemFirstDate.format());

      // Render all the unique dates
      this.container.innerHTML = app.templating.render({
        dates: uniqueDates
      }, 'common.season-dates-inner');
      this.sortItem();
    }

    /**
     * Sort Item
     *
     * Loops through the items parent and figures out where in the order,
     * using its new dates, it should sit.
     */
    sortItem() {
      /** If there are more than one items in a month and it hasn't been
       * sorted already, check if it needs sorting */
      if (this.itemListEle.children.length > 1 && !core.style.hasClass(this.itemEle, 'is-sorted')) {
        const sortDirection = this.itemListEle.getAttribute('data-sort') || 'asc';
        for (let i = 0, length = this.itemListEle.children.length; i < length; i++) {
          const currentChild = this.itemListEle.children[i];

          // Skip over child if itself
          if (currentChild === this.itemEle) {
            continue;
          }
          const currentDateAttr = currentChild.getAttribute('data-from');
          if (!currentDateAttr) {
            continue;
          }
          const currentDate = dayjs(currentDateAttr);
          if (sortDirection === 'asc') {
            /** If the current child is after the item, insert it before
             * and break out the loop */
            if (currentDate.isAfter(this.itemFirstDate)) {
              this.itemListEle.insertBefore(this.itemEle, currentChild);
              break;
            } else if (i === length - 1 && currentDate.isBefore(this.itemFirstDate)) {
              this.itemListEle.appendChild(this.itemEle);
            }
          } else if (sortDirection === 'desc') {
            /** If the current child is before the item, insert it before
             * and break out the loop */
            if (currentDate.isBefore(this.itemFirstDate)) {
              this.itemListEle.insertBefore(this.itemEle, currentChild);
              break;
            } else if (i === length - 1 && currentDate.isAfter(this.itemFirstDate)) {
              this.itemListEle.appendChild(this.itemEle);
            }
          }
        }
      }

      // Add class so it isn't sorted again
      core.style.addClass(this.itemEle, 'is-sorted');
    }
  };

  // initialise on article pages
  app.widgetInitialiser.addMultipleWidgetsByName('season-dates', app.SeasonDatesWidget);
})(PULSE.app, PULSE.app.common, PULSE.core);
"use strict";

(function (app, common, core) {
  const INTERVAL = 50;
  const ENABLE_ANIMATION_CLASS = 'will-animate';

  /**
   * @typedef {Object} SliderConfig configuration for the slider widget
   * @property {HTMLElement} container the element that will wrap the slider widget
   * @property {HTMLElement} slideContainer the element that will be scrolled in the slider, defaults to lookup '.js-slider' within container
   * @property {NodeList} sliderElements list of slide elements, defaults to lookup '.js-slide' within container
   * @property {HTMLElement} nextButton the next button, defaults to lookup '.js-nextBtn' within container
   * @property {HTMLElement} prevButton the previous button, defaults to lookup '.js-prevBtn' within container
   * @property {String} [nudgeLeftClass] the class to apply to the container to nudge it left, defaults to nudge-left
   * @property {String} [nudgeRightClass] the class to apply to the container to nudge it right, defaults to nudge-right
   * @property {Integer} [perPage] how many sliderElements should be incremented per slide, defaults to 1
   * @property {NodeList} [pagerElements] the page indication elements
   * @property {NodeList} [pagerItemsContainer] the container element for the pager items
   * @property {String} [itemActiveClass] the class to apply to an active slide item, defaults to item-active
   * @property {String} [pagerActiveClass] the class to apply to an active pager element, defaults to active-pager
   * @property {String} [buttonHideClass] the class to apply to the next or previous buttons when hidden, defaults to u-hide
   * @property {Function} [nextCallback] function to call when the next button is clicked
   * @property {Function} [previousCallback] function to call when the previous button is clicked
   * @property {Function} [paginationCallback] function to call when the pagination button is clicked
   * @property {Function} [slideChangeCallback] function to call when the slide changes
   */

  let configChecks = [{
    namespace: 'container'
  }, {
    namespace: 'slideContainer',
    type: 'HTMLElement',
    selector: '.js-slider'
  }, {
    namespace: 'sliderElements',
    type: 'NodeList',
    selector: '.js-slide'
  }, {
    namespace: 'nextButton',
    type: 'HTMLElement',
    selector: '.js-next-btn'
  }, {
    namespace: 'prevButton',
    type: 'HTMLElement',
    selector: '.js-prev-btn'
  }, {
    'namespace': 'nudgeLeftClass',
    'default': 'nudge-left'
  }, {
    'namespace': 'nudgeRightClass',
    'default': 'nudge-right'
  }, {
    'namespace': 'pagerActiveClass',
    'default': 'is-active'
  }, {
    'namespace': 'itemActiveClass',
    'default': 'item-active'
  }, {
    'namespace': 'buttonHideClass',
    'default': 'u-hide'
  }];
  const OBSERVER_CONFIG = {
    root: null,
    // default to browser viewport
    rootMargin: '0px',
    threshold: [0.1, 0.9] // eslint-disable-line no-magic-numbers
  };

  /**
   * Creates slider interaction from a list, displays next and
   * previous buttons and a bottom pagination indicator
   * @param {SliderConfig} config the slider configuration
   * @constructor
   */
  common.ContentCarousel = function (config) {
    this.sliderInitialised = false;

    // the index value of the first item in the active slide
    this.activeItemIndex;

    // Set config based on argument and defaults
    this.config = common.configChecker('common.ContentCarousel', config, configChecks);

    // Ensure valid config before building component
    if (this.config) {
      this.observer = new IntersectionObserver(_onActivate.bind(this), OBSERVER_CONFIG);
      this.observer.observe(this.config.container);
    }
  };
  common.ContentCarousel.prototype.initSlider = function () {
    const _self = this;
    _calculatePresets.call(this);
    if (_self.config.perPage === 0) {
      console.error('Something went wrong with the slider for', _self.config.container);
      return;
    }
    _self.activeSlide = _self.config.activeSlide || 0;
    _self.renderPagination();
    if (_self.sliderInitialised) {
      // if slider has already been initialised then only the pager btns will need listeners updating
      _self.setPagerListeners();
    } else {
      _self.setListeners();
    }
    _self.slideTo(_self.activeSlide);
    _self.sliderInitialised = true;
    setTimeout(() => {
      _self.config.slideContainer.classList.add(ENABLE_ANIMATION_CLASS);
    }, 0);
    common.fireEvent(common.CONSTANTS.EVENTS.SLIDER.INITIALISED, {}, _self.config.container);
  };
  common.ContentCarousel.prototype.setListeners = function () {
    const _self = this;
    _self.config.nextButton.addEventListener('click', function () {
      _self.scrollNext();
    });
    _self.config.prevButton.addEventListener('click', function () {
      _self.scrollPrev();
    });
    _self.setPagerListeners();
    _self.lastWidth = window.innerWidth;
    core.event.windowResize.add({
      method: () => {
        if (_self.lastWidth !== window.innerWidth) {
          _self.resetSlider.call(_self);
          _self.lastWidth = window.innerWidth;
        }
      }
    });

    // interval timer that will be fired on scroll to determine when scroll has finished
    _self.interval = null;

    // Listen for scroll events
    // This is to trigger item snapping on mobile sliders
    // The listener will only be fired on mobile as desktop uses translate to move items
    _self.config.slideContainer.addEventListener('scroll', function () {
      if (!_self.interval) {
        _self.checkScroll();
      }
    });
  };
  common.ContentCarousel.prototype.setPagerListeners = function () {
    const _self = this;
    if (_self.config.pagerElements) {
      for (let i = 0; i < _self.config.pagerElements.length; i++) {
        _self.config.pagerElements[i].addEventListener('click', _self.slideTo.bind(_self, i));
      }
    }
  };

  //one slide right
  common.ContentCarousel.prototype.scrollNext = function () {
    const _self = this;

    // check if already at last slide
    if (_self.activeSlide === _self.slideNum - 1) {
      return;
    }
    _self.activeSlide++;
    _self.slideTo(_self.activeSlide);
    if (_self.config.nextCallback) {
      _self.config.nextCallback(_self.activeSlide);
    }
  };
  common.ContentCarousel.prototype.nudgeLeft = function () {
    const _self = this;
    core.style.toggleClass(_self.config.slideContainer, _self.config.nudgeLeftClass);
  };
  common.ContentCarousel.prototype.nudgeRight = function () {
    const _self = this;
    core.style.toggleClass(_self.config.slideContainer, _self.config.nudgeRightClass);
  };
  common.ContentCarousel.prototype.isPaginating = function () {
    const _self = this;
    return _self.config.pagerItemsContainer ? _self.config.pagerItemsContainer.offsetParent : false;
  };

  //one slide left
  common.ContentCarousel.prototype.scrollPrev = function () {
    const _self = this;

    // check if already at first slide
    if (_self.activeSlide === 0) {
      return;
    }
    _self.activeSlide--;
    _self.slideTo(_self.activeSlide);
    if (_self.config.previousCallback) {
      _self.config.previousCallback(_self.activeSlide);
    }
  };

  //when pager is clicked jump the the slide that matches that buttons index
  common.ContentCarousel.prototype.slideTo = function (slideIndex) {
    const _self = this;
    let direction = _self.activeSlide < slideIndex;
    _self.activeSlide = slideIndex;
    _self.updateControls();
    _self.setActiveItems();
    let activeSlidesNumber = _self.getNumberOfActiveItems();

    // checks that if the next slide of items isn't a full slide it won't do a full scroll
    if (activeSlidesNumber < _self.config.perPage) {
      let position = _self.slideWidth * slideIndex;
      let newWidth = _self.slideWidth - _self.slideWidth / _self.config.perPage * activeSlidesNumber;
      // new start index of the active slide items because active slide is not a full slide
      let startIndex = _self.activeItemIndex - (_self.config.perPage - activeSlidesNumber);
      _self.setActiveItems(startIndex);
      _self.slidePos = position - newWidth;
    } else {
      _self.slidePos = _self.slideWidth * slideIndex;
    }
    if (window.innerWidth > app.measurements.tablet) {
      _self.config.slideContainer.style.transform = 'translate3d( -' + _self.slidePos + 'px, 0, 0)';
    } else {
      _self.config.slideContainer.style.transform = 'translate3d( 0, 0, 0)';
      _self.config.slideContainer.scrollLeft = _self.slidePos;
    }
    if (_self.config.paginationCallback) {
      _self.config.paginationCallback(direction);
    }
    if (_self.config.slideChangeCallback) {
      _self.config.slideChangeCallback(_self.activeSlide);
    }
  };
  common.ContentCarousel.prototype.updateControls = function () {
    const _self = this;

    //if there are no more slides after this hide next button
    if (_self.activeSlide >= _self.slideNum - 1) {
      core.style.addClass(_self.config.nextButton, _self.config.buttonHideClass);
      //otherwise show this button
    } else if (core.style.hasClass(_self.config.nextButton, _self.config.buttonHideClass)) {
      core.style.removeClass(_self.config.nextButton, _self.config.buttonHideClass);
    }
    if (_self.activeSlide === 0) {
      core.style.addClass(_self.config.prevButton, _self.config.buttonHideClass);
    } else if (core.style.hasClass(_self.config.prevButton, _self.config.buttonHideClass)) {
      core.style.removeClass(_self.config.prevButton, _self.config.buttonHideClass);
    }
    if (_self.config.pagerElements) {
      //update the active pager button to match the activeSlide number
      for (let i = 0; i < _self.config.pagerElements.length; i++) {
        if (i === _self.activeSlide) {
          core.style.addClass(_self.config.pagerElements[i], _self.config.pagerActiveClass);
        } else {
          core.style.removeClass(_self.config.pagerElements[i], _self.config.pagerActiveClass);
        }
      }
    }
  };

  /**
   * Renders the pips underneath the slider
   */
  common.ContentCarousel.prototype.renderPagination = function () {
    const _self = this;
    if (_self.config.pagerElements) {
      _self.config.pagerItemsContainer.innerHTML = app.templating.render({
        activeIndex: _self.config.activeSlide,
        slidenumbers: _self.getNumberOfSlides() + 1 // not zero based
      }, 'common.ContentCarousel-pagination');
    }
  };

  /**
   * Returns the current number of active items in the slider
   * @returns { Number } Number of active items
   */
  common.ContentCarousel.prototype.getNumberOfActiveItems = function () {
    const _self = this;
    let items = _self.config.slideContainer.querySelectorAll('.' + _self.config.itemActiveClass);
    return items.length;
  };

  /**
   * How many slides are in the slider
   * @returns { Number } Number of slides
   */
  common.ContentCarousel.prototype.getNumberOfSlides = function () {
    const _self = this;
    return Math.ceil(_self.config.sliderElements.length / _self.config.perPage - 1);
  };
  common.ContentCarousel.prototype.getActiveSlide = function () {
    const _self = this;
    return _self.activeSlide;
  };

  /**
   * Return the slide number of the item this function is passed
   * @param  {Node} slideItem element to query
   * @returns {Number} The slide index that slideItem sits in
   */
  common.ContentCarousel.prototype.getItemSlide = function (slideItem) {
    const _self = this;

    // convert node list to array
    const elementArray = Array.prototype.slice.call(_self.config.sliderElements);
    const index = elementArray.indexOf(slideItem);
    const slideIndex = Math.floor(index / _self.config.perPage);
    return slideIndex;
  };

  /**
   * function to set the four items currently active in slider so they're shown with full opacity
   * @param  {number} startingIndex if you need to define a startingIndex to set active classes on
   */
  common.ContentCarousel.prototype.setActiveItems = function (startingIndex) {
    const _self = this;
    for (let i = 0; i < _self.config.sliderElements.length; i++) {
      core.style.removeClass(_self.config.sliderElements[i], _self.config.itemActiveClass);
    }
    let firstItemIndex = _self.activeSlide * _self.config.perPage;
    if (startingIndex) {
      firstItemIndex = startingIndex;
    }
    _self.activeItemIndex = firstItemIndex;
    for (let i = 0; i < _self.config.perPage; i++) {
      if (!_self.config.sliderElements[firstItemIndex]) {
        break;
      }
      core.style.addClass(_self.config.sliderElements[firstItemIndex], _self.config.itemActiveClass);
      firstItemIndex++;
    }
  };
  common.ContentCarousel.prototype.resetSlider = function () {
    const _self = this;
    _self.config.slideContainer.classList.remove(ENABLE_ANIMATION_CLASS);
    setTimeout(() => {
      _self.initSlider();
    }, 0);
    common.fireEvent(common.CONSTANTS.EVENTS.SLIDER.INITIALISED, {}, _self.config.container);
  };

  /**
   * Only for mobile sliders
   * Detect when the mobile scroller has stopped scrolling to then trigger snap
   */
  common.ContentCarousel.prototype.checkScroll = function () {
    const _self = this;
    let pos = _self.config.slideContainer.scrollLeft;
    _self.interval = setInterval(function () {
      let newPos = _self.config.slideContainer.scrollLeft;
      if (newPos === pos) {
        clearInterval(_self.interval);
        _self.interval = null;
        const ONE_AND_A_HALF_TIMES = 1.5;
        // only if you're likely to not see the slider item should it snap to centre
        if (window.innerWidth < _self.slideWidth * ONE_AND_A_HALF_TIMES) {
          _self.snapSlider();
        }
      } else {
        pos = newPos;
      }
    }, INTERVAL);
  };

  /**
   * Only for mobile sliders
   * When scroll has finished will position the most in view element correctly
   */
  common.ContentCarousel.prototype.snapSlider = function () {
    const _self = this;
    const firstSlideRect = _self.config.sliderElements[0].getBoundingClientRect();
    const fullItemWidth = firstSlideRect.width;
    const slideWidth = fullItemWidth * _self.config.perPage;
    const currentScrollPosition = _self.config.slideContainer.scrollLeft;

    // how far an item needs to be from the left edge of the page to be visually centre-aligned
    const leftOffset = (window.innerWidth - slideWidth) / 2;

    // how much the 1st element is offset from the left of the scrolling container
    const initialOffset = Math.abs(firstSlideRect.left + currentScrollPosition);

    // how much to add to the scroll to visually centre the element
    const scrollOffset = initialOffset - leftOffset;
    for (let slideIndex = 0; slideIndex < _self.config.sliderElements.length; slideIndex++) {
      let slideEl = _self.config.sliderElements[slideIndex];
      let minPos = slideEl.offsetLeft - fullItemWidth / 2;
      let maxPos = slideEl.offsetLeft + fullItemWidth / 2;

      // if more than half of the slide is visible, this is the one to snap to
      if ((currentScrollPosition - minPos) * (currentScrollPosition - maxPos) <= 0) {
        const numberOfSlidesToScroll = slideIndex;
        _self.config.slideContainer.scrollLeft = fullItemWidth * numberOfSlidesToScroll + scrollOffset;

        // if this is different from the current slide, update the current slide
        if (_self.activeSlide !== slideIndex) {
          _self.activeSlide = slideIndex;
          _self.updateControls();
          _self.setActiveItems();
          if (_self.config.slideChangeCallback) {
            _self.config.slideChangeCallback(_self.activeSlide);
          }
        }
        return;
      }
    }
  };

  /**
   * PRIVATE FUNCTIONS
   */

  /**
   * Goes through the DOM and determines what the page size for the slider is, what the width is etc.
   */
  const _calculatePresets = function _calculatePresets() {
    const slideItems = [].slice.call(this.config.slideContainer.children);
    /**
     * Iterates through slide container elements and counts how many are visible
     * then sets the number of items per page based on this
     */
    this.config.perPage = slideItems.filter(item => {
      return _isVisibleInSlideView(item, this.config.slideContainer);
    }).length || 1;
    this.slidePos = 0;
    const firstSlideRect = this.config.sliderElements[0].getBoundingClientRect();
    this.itemWidth = firstSlideRect.width;
    this.slideWidth = this.itemWidth * this.config.perPage;
    this.slideNum = Math.ceil(this.config.sliderElements.length / this.config.perPage);
  };

  /**
   * Check if the given element is visible within the scroll view of the carousel slider
   *
   * @param  {HTMLElement} element The element to test if it is visible within the scroll container
   * @param  {HTMLElement} wrapper The scroll container to set the bounding restrictions for which elements are tested against
   * @return {Boolean}         Returns true if the passed in element is visible inside the wrapper
   */
  const _isVisibleInSlideView = function _isVisibleInSlideView(element, wrapper) {
    const rect = element.getBoundingClientRect();
    const containerRect = wrapper.getBoundingClientRect();
    const leftInView = Math.ceil(rect.left) >= Math.floor(containerRect.left);
    const rightInView = Math.floor(rect.right) <= Math.ceil(containerRect.right);
    return leftInView && rightInView;
  };

  /**
   * Function called when the slider comes into view
   * @param  {Object[]} observedItems Intersection observer array of observed items coming into view
   */
  const _onActivate = function _onActivate(observedItems) {
    const _self = this;
    Array.prototype.forEach.call(observedItems, function (observedItem) {
      const element = observedItem.target;
      // if the widget should be initialized
      if (observedItem.isIntersecting && element.dataset.calculationsComplete !== 'true') {
        _self.initSlider();
        element.dataset.calculationsComplete = 'true';
      }
    });
  };
})(PULSE.app, PULSE.app.common, PULSE.core);
"use strict";

(function (app, core, common) {
  const COPY = {
    button: '.js-copy-url',
    message: '.js-copy-message'
  };
  const CLASS = {
    open: 'is-open',
    hide: 'u-hide',
    active: 'is-active',
    copyFail: 'social-share__copy-message--fail'
  };

  /**
  * constructor for the page share widget. Widget requires following data attributes to be
  * present on target button elements;
  *
  * data-social - if this contains a url then it will be used as the page share url
  * data-social-service - the service name ( should correlate to an entry in the socialLinks
  * object that is defined in socialHelper Class - ../../js/social-helpers.js)
  *
  * @param {Object} element element defining the page share widget
  * @param {string} url     URL to share
  * @constructor
  */
  common.SharePage = function (element, url) {
    const _self = this;
    _self.element = element;
    _self.render = _self.element.getAttribute('data-render');
    _self.bodyContent = _self.element.getAttribute('data-body');
    _self.defaultClosed = _self.element.getAttribute('data-closed');

    //copy url to clipboard
    _self.copyBtn = _self.element.querySelector(COPY.button);
    _self.copyMessage = _self.element.querySelector(COPY.message);
    _self.url = _self.element.getAttribute('data-link-to') ? window.location.hostname + _self.element.getAttribute('data-link-to') : url;
    _self.setListeners();
  };

  /**
  * start listening for click events on the element
  */
  common.SharePage.prototype.setListeners = function () {
    const _self = this;

    // bind clicks on individual social buttons
    common.addAriaClickListener(_self.element, event => {
      // handle clicks on individual social clicks
      const clicked = _self.getSocialDataset(event.target);
      if (clicked && clicked.socialService) {
        app.socialHelpers[clicked.socialService].sharePage(_self.url, false, _self.updateBodyContent());
      }
    });
    common.addAriaClickListener(_self.copyBtn, () => _self.copyUrl());
  };

  /**
  * Copy url to clipboard
  */
  common.SharePage.prototype.copyUrl = function () {
    const _self = this;
    const url = _self.url || window.location.href;

    // eslint-disable-next-line no-undef
    clipboard.writeText(url).then(() => _self.copyUrlMessage(), () => _self.copyUrlMessage(true));
  };

  /**
  * Display a message that tells the user if the url has been copied to the clipboard
  * or not
  *
  * @param {boolean} fail - true if copying to the clipboard has failed
  */
  common.SharePage.prototype.copyUrlMessage = function (fail) {
    const _self = this;
    const delayTime = 2000;
    _self.copyBtn.classList.add(CLASS.active);
    if (fail) {
      _self.copyMessage.classList.add(CLASS.copyFail);
      _self.copyMessage.innerHTML = 'URL could not be copied';
    }
    setTimeout(function () {
      _self.copyBtn.classList.remove(CLASS.active);
    }, delayTime);
  };

  /**
  * move up the dom tree to find the element containing the desired data attributes. Do not traverse up past the
  * widget container. return the data set attribute of the element.
  *
  * @param {object} element DOM Element on which to begin the traversal
  * @returns {object} hash - dataset attribute of the element or fale if no element can be found
  */
  common.SharePage.prototype.getSocialDataset = function (element) {
    const _self = this;
    let inspecting = element;
    const checkThisElement = _self.element.getAttribute('data-social-service');
    if (checkThisElement) {
      return _self.element.dataset;
    }
    do {
      const thisAtt = inspecting.getAttribute('data-social-service');
      if (thisAtt) {
        return inspecting.dataset;
      }
      inspecting = inspecting.parentElement;
    } while (inspecting && inspecting !== _self.element);
    return false;
  };

  /**
  * updates the bodyContent for already created listeners (in some cases we might want to change the
   * message to share without creating a new instance)
  *
  * @returns {string} watever contains the 'data-body' attribute
  */
  common.SharePage.prototype.updateBodyContent = function () {
    const _self = this;
    return _self.element.getAttribute('data-body');
  };
  app.widgetInitialiser.addMultipleWidgetsByName('social-share-page', common.SharePage);
})(PULSE.app, PULSE.core, PULSE.app.common);
"use strict";

/*eslint no-param-reassign: "warn"*/
/*eslint new-cap: "warn"*/

(function (app) {
  'use strict';

  //Social constants
  const TWITTER = 'twitter';
  const FACEBOOK = 'facebook';
  const WHATSAPP = 'whatsapp';
  const GOOGLEPLUS = 'googleplus';
  const EMAIL = 'email';
  const FACEBOOK_MESSENGER = 'facebookMessenger';
  const TITLE_SELECTOR = '.js-page-title';
  const TWITTER_VIA = () => PULSE.I18N.lookup('label.twitter.via');
  const VIA = () => PULSE.I18N.lookup('label.social.via');

  /**
   * Create a set of basic functionality that social widgets will share
   * Individual social helpers can be extended with extra functions in ./social-service
   *
   * @param {string} serviceName name of the social service, should correlate to an entry
   * in socialLinks object
   *
   * @constructor
   */
  const SocialHelper = function SocialHelper(serviceName) {
    const _self = this;
    _self.name = serviceName;
    _self.socialLinks = {
      twitter: {
        url: 'http://www.twitter.com/intent/tweet?text='
      },
      facebook: {
        url: 'http://www.facebook.com/sharer/sharer.php?u='
      },
      facebookMessenger: {
        url: 'fb-messenger://share/?link='
      },
      googleplus: {
        url: 'http://plus.google.com/share?url='
      },
      whatsapp: {
        url: 'whatsapp://send?text='
      },
      email: {
        url: 'mailto:?body='
      }
    };
    _self.defaultWindowConfiguration = {
      width: '500',
      height: '500',
      menubar: 0,
      location: 1,
      resizable: 0,
      scrollbars: 0,
      status: 0,
      titlebar: 0,
      toolbar: 0
    };
  };

  /**
  * Share a page url or the current page url ( if no url passed ) to the social
  * media site with which the instance was created
  *
  * @param {string} url 		 the url to share on the social media site
  * @param {string} body 	 the share message
  * @returns {string} page url
  */
  SocialHelper.prototype.buildShareUrl = function buildShareUrl(url, body) {
    const _self = this;
    const shareURL = url || window.location.href;
    const pageTitle = getPageTitle();
    const network = _self.socialLinks[_self.name].url;
    switch (_self.name) {
      case FACEBOOK:
      case GOOGLEPLUS:
      case FACEBOOK_MESSENGER:
        return network + encodeURIComponent(shareURL);
      case TWITTER:
        if (body) {
          return network + encodeURIComponent(`${body} ${TWITTER_VIA()} ${shareURL}`);
        } else if (pageTitle) {
          return network + encodeURIComponent(`${pageTitle} ${TWITTER_VIA()} ${shareURL}`);
        }
        return network + encodeURIComponent(`${shareURL} ${TWITTER_VIA()}`);
      default:
        if (pageTitle) {
          return network + encodeURIComponent(`${pageTitle} ${VIA()} ${shareURL}`);
        }
        return network + encodeURIComponent(`${body} ${VIA()} ${shareURL}`);
    }
  };

  /**
   * creates a string representation of the configuration object provided so
   * it can be used in the call to window.open, for example;
  *
  * "menubar=no,location=yes,resizable=yes,scrollbars=yes,status=yes"
  *
  * @param {object} windowConfiguration the configuration object to stringify
  * @returns {string} comma separated list of configuration parameters
  */
  SocialHelper.prototype.makeWindowConfigString = function makeWindowConfigString(windowConfiguration) {
    const _self = this;
    const config = windowConfiguration || _self.defaultWindowConfiguration;
    const settings = Object.keys(config);
    return settings.reduce((acc, cur) => acc += `${cur}=${config[cur]},`, []);
  };

  /**
  * create a share url for the service with which the instance was created and open a
  * new window using the parameters provided, or the defaults.
  *
  * @param {string} url   optionally provide a specific url to link to, otherwise the current window.location
  * @param {object} windowConfiguration optionally provide a window configuration object
  * @param {string} body the share message to include if present
  */
  SocialHelper.prototype.sharePage = function sharePage(url, windowConfiguration, body) {
    const _self = this;
    const shareURL = _self.buildShareUrl(url, body);
    const config = _self.makeWindowConfigString(windowConfiguration);
    window.open(shareURL, '_blank', config);
  };

  /**
   * Get page title
   *
   * @return { HTMLElement } return selected element or null
   */
  const getPageTitle = () => {
    return document.querySelector(TITLE_SELECTOR);
  };

  /**
  * keep the social helpers under the app object
  *
  * @type {{twitter: socialHelper, facebook: socialHelper, google: socialHelper}}
  */
  app.socialHelpers = {
    twitter: new SocialHelper(TWITTER),
    facebook: new SocialHelper(FACEBOOK),
    google: new SocialHelper(GOOGLEPLUS),
    email: new SocialHelper(EMAIL),
    whatsapp: new SocialHelper(WHATSAPP),
    facebookMessenger: new SocialHelper(FACEBOOK_MESSENGER)
  };
})(PULSE.app);