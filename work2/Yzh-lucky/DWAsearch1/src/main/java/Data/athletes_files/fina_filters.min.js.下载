"use strict";

PULSE.app.templates['filters.lazy-flag'] = _.template("<div class=\"flag <%= typeof cssClass !== 'undefined' ? cssClass : '' %> js-lazy-flag\"> <!--\n        <img class=\"flag__img\" aria-hidden=\"true\" src=\"<%= environment.cdn %>i/elements/flags/<%= countryCode.toLowerCase() %>.png\" alt=\"<%= countryCode %>\">\n    --> </div>");
PULSE.app.templates['filters.listbox'] = _.template("<div class=\"listbox <%= typeof cssClass !== 'undefined' ? cssClass : '' %>\" id=\"<%= id %>\"> <button aria-haspopup=\"listbox\" aria-labelledby=\"listbox-label-<%= id %> listbox-button-<%= id %>\" id=\"listbox-button-<%= id %>\" class=\"listbox__button js-listbox-button u-hide-tablet\"> <% if ( typeof label !== 'undefined' ) { %> <span class=\"listbox__label\" id=\"listbox__label-<%= id %>\"> <%= label %>: </span> <% } %> <span class=\"listbox__button-label js-listbox-button-label\"> <% if ( options.length ) { %> <% if ( splitByLetter && optionsByLetter.set.length ) { %> <%= optionsByLetter[ optionsByLetter.set[ 0 ] ][ 0 ].label %> <% } else { %> <%= options[ 0 ].label %> <% } %> <% } %> </span> <%= render( {\n            cssClass: 'listbox__icon',\n            name: 'unfold'\n        }, 'common.render-svg' ) %> </button> <ul class=\"listbox__list js-listbox-list u-hide-tablet\" tabindex=\"-1\" role=\"listbox\" aria-labelledby=\"listbox__label-<%= id %>\"> <% if ( splitByLetter && optionsByLetter.set.length ) { %> <% optionsByLetter.set.forEach( function( letter ) { %> <li class=\"listbox__section-title\"> <%= letter %> </li> <% optionsByLetter[ letter ].forEach( function( option ) { %> <li class=\"listbox__option\" id=\"<%= id %>--<%= option.value %>\" role=\"option\" data-value=\"<%= option.value %>\"> <span class=\"listbox__option-label-wrap\"> <span class=\"listbox__option-label link-underline\"> <%= option.label %> </span> </span> </li> <% } ) %> <% } ) %> <% } else { %> <% options.forEach( function( option ) { %> <li class=\"listbox__option link-underline-trigger\" id=\"<%= id %>--<%= option.value %>\" role=\"option\" data-value=\"<%= option.value %>\"> <span class=\"listbox__option-label-wrap\"> <span class=\"listbox__option-label link-underline\"> <%= option.label %> </span> </span> </li> <% } ) %> <% } %> </ul> <div class=\"listbox__select-wrapper u-show-tablet\"> <% if ( typeof label !== 'undefined' ) { %> <label class=\"listbox__select-label\" for=\"<%= id %>-select\"> <%= label %>: </label> <% } %> <select name=\"<%= id %>-select\" id=\"listbox-select-<%= id %>\" class=\"listbox__select js-listbox-select\"> <% options.forEach( function( option ) { %> <option value=\"<%= option.value %>\"><%= option.textLabel || option.label %></option> <% } ) %> </select> <%= render( {\n            cssClass: 'listbox__select-icon',\n            name: 'unfold'\n        }, 'common.render-svg' ) %> </div> </div> ");
!function (e, t) {
  "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.datepicker = t() : e.datepicker = t();
}(window, function () {
  return function (e) {
    var t = {};
    function n(a) {
      if (t[a]) return t[a].exports;
      var r = t[a] = {
        i: a,
        l: !1,
        exports: {}
      };
      return e[a].call(r.exports, r, r.exports, n), r.l = !0, r.exports;
    }
    return n.m = e, n.c = t, n.d = function (e, t, a) {
      n.o(e, t) || Object.defineProperty(e, t, {
        enumerable: !0,
        get: a
      });
    }, n.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(e, "__esModule", {
        value: !0
      });
    }, n.t = function (e, t) {
      if (1 & t && (e = n(e)), 8 & t) return e;
      if (4 & t && "object" == typeof e && e && e.__esModule) return e;
      var a = Object.create(null);
      if (n.r(a), Object.defineProperty(a, "default", {
        enumerable: !0,
        value: e
      }), 2 & t && "string" != typeof e) for (var r in e) n.d(a, r, function (t) {
        return e[t];
      }.bind(null, r));
      return a;
    }, n.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };
      return n.d(t, "a", t), t;
    }, n.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, n.p = "", n(n.s = 0);
  }([function (e, t, n) {
    "use strict";

    n.r(t);
    var a = [],
      r = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      i = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      o = {
        t: "top",
        r: "right",
        b: "bottom",
        l: "left",
        c: "centered"
      };
    function s() {}
    var l = ["click", "focusin", "keydown", "input"];
    function d(e) {
      l.forEach(function (t) {
        e.addEventListener(t, e === document ? L : Y);
      });
    }
    function c(e) {
      return Array.isArray(e) ? e.map(c) : "[object Object]" === x(e) ? Object.keys(e).reduce(function (t, n) {
        return t[n] = c(e[n]), t;
      }, {}) : e;
    }
    function u(e, t) {
      var n = e.calendar.querySelector(".qs-overlay"),
        a = n && !n.classList.contains("qs-hidden");
      t = t || new Date(e.currentYear, e.currentMonth), e.calendar.innerHTML = [h(t, e, a), f(t, e, a), v(e, a)].join(""), a && window.requestAnimationFrame(function () {
        M(!0, e);
      });
    }
    function h(e, t, n) {
      return ['<div class="qs-controls' + (n ? " qs-blur" : "") + '">', '<div class="qs-arrow qs-left"></div>', '<div class="qs-month-year' + (t.disableYearOverlay ? " qs-disabled-year-overlay" : "") + '">', '<span class="qs-month">' + t.months[e.getMonth()] + "</span>", '<span class="qs-year">' + e.getFullYear() + "</span>", "</div>", '<div class="qs-arrow qs-right"></div>', "</div>"].join("");
    }
    function f(e, t, n) {
      var a = t.currentMonth,
        r = t.currentYear,
        i = t.dateSelected,
        o = t.maxDate,
        s = t.minDate,
        l = t.showAllDates,
        d = t.days,
        c = t.disabledDates,
        u = t.startDay,
        h = t.weekendIndices,
        f = t.events,
        v = t.getRange ? t.getRange() : {},
        m = +v.start,
        y = +v.end,
        p = g(new Date(e).setDate(1)),
        w = p.getDay() - u,
        D = w < 0 ? 7 : 0;
      p.setMonth(p.getMonth() + 1), p.setDate(0);
      var b = p.getDate(),
        q = [],
        S = D + 7 * ((w + b) / 7 | 0);
      S += (w + b) % 7 ? 7 : 0;
      for (var M = 1; M <= S; M++) {
        var E = (M - 1) % 7,
          x = d[E],
          C = M - (w >= 0 ? w : 7 + w),
          L = new Date(r, a, C),
          Y = f[+L],
          j = C < 1 || C > b,
          O = j ? C < 1 ? -1 : 1 : 0,
          P = j && !l,
          k = P ? "" : L.getDate(),
          N = +L == +i,
          _ = E === h[0] || E === h[1],
          I = m !== y,
          A = "qs-square " + x;
        Y && !P && (A += " qs-event"), j && (A += " qs-outside-current-month"), !l && j || (A += " qs-num"), N && (A += " qs-active"), (c[+L] || t.disabler(L) || _ && t.noWeekends || s && +L < +s || o && +L > +o) && !P && (A += " qs-disabled"), +g(new Date()) == +L && (A += " qs-current"), +L === m && y && I && (A += " qs-range-start"), +L > m && +L < y && (A += " qs-range-middle"), +L === y && m && I && (A += " qs-range-end"), P && (A += " qs-empty", k = ""), q.push('<div class="' + A + '" data-direction="' + O + '">' + k + "</div>");
      }
      var R = d.map(function (e) {
        return '<div class="qs-square qs-day">' + e + "</div>";
      }).concat(q);
      return R.unshift('<div class="qs-squares' + (n ? " qs-blur" : "") + '">'), R.push("</div>"), R.join("");
    }
    function v(e, t) {
      var n = e.overlayPlaceholder,
        a = e.overlayButton;
      return ['<div class="qs-overlay' + (t ? "" : " qs-hidden") + '">', "<div>", '<input class="qs-overlay-year" placeholder="' + n + '" inputmode="numeric" />', '<div class="qs-close">&#10005;</div>', "</div>", '<div class="qs-overlay-month-container">' + e.overlayMonths.map(function (e, t) {
        return '<div class="qs-overlay-month" data-month-num="' + t + '">' + e + "</div>";
      }).join("") + "</div>", '<div class="qs-submit qs-disabled">' + a + "</div>", "</div>"].join("");
    }
    function m(e, t, n) {
      var a = t.el,
        r = t.calendar.querySelector(".qs-active"),
        i = e.textContent,
        o = t.sibling;
      (a.disabled || a.readOnly) && t.respectDisabledReadOnly || (t.dateSelected = n ? void 0 : new Date(t.currentYear, t.currentMonth, i), r && r.classList.remove("qs-active"), n || e.classList.add("qs-active"), p(a, t, n), n || q(t), o && (y({
        instance: t,
        deselect: n
      }), t.first && !o.dateSelected && (o.currentYear = t.currentYear, o.currentMonth = t.currentMonth, o.currentMonthName = t.currentMonthName), u(t), u(o)), t.onSelect(t, n ? void 0 : new Date(t.dateSelected)));
    }
    function y(e) {
      var t = e.instance.first ? e.instance : e.instance.sibling,
        n = t.sibling;
      t === e.instance ? e.deselect ? (t.minDate = t.originalMinDate, n.minDate = n.originalMinDate) : n.minDate = t.dateSelected : e.deselect ? (n.maxDate = n.originalMaxDate, t.maxDate = t.originalMaxDate) : t.maxDate = n.dateSelected;
    }
    function p(e, t, n) {
      if (!t.nonInput) return n ? e.value = "" : t.formatter !== s ? t.formatter(e, t.dateSelected, t) : void (e.value = t.dateSelected.toDateString());
    }
    function w(e, t, n, a) {
      n || a ? (n && (t.currentYear = +n), a && (t.currentMonth = +a)) : (t.currentMonth += e.contains("qs-right") ? 1 : -1, 12 === t.currentMonth ? (t.currentMonth = 0, t.currentYear++) : -1 === t.currentMonth && (t.currentMonth = 11, t.currentYear--)), t.currentMonthName = t.months[t.currentMonth], u(t), t.onMonthChange(t);
    }
    function D(e) {
      if (!e.noPosition) {
        var t = e.position.top,
          n = e.position.right;
        if (e.position.centered) return e.calendarContainer.classList.add("qs-centered");
        var a = e.positionedEl.getBoundingClientRect(),
          r = e.el.getBoundingClientRect(),
          i = e.calendarContainer.getBoundingClientRect(),
          o = r.top - a.top + (t ? -1 * i.height : r.height) + "px",
          s = r.left - a.left + (n ? r.width - i.width : 0) + "px";
        e.calendarContainer.style.setProperty("top", o), e.calendarContainer.style.setProperty("left", s);
      }
    }
    function b(e) {
      return "[object Date]" === x(e) && "Invalid Date" !== e.toString();
    }
    function g(e) {
      if (b(e) || "number" == typeof e && !isNaN(e)) {
        var t = new Date(+e);
        return new Date(t.getFullYear(), t.getMonth(), t.getDate());
      }
    }
    function q(e) {
      e.disabled || !e.calendarContainer.classList.contains("qs-hidden") && !e.alwaysShow && ("overlay" !== e.defaultView && M(!0, e), e.calendarContainer.classList.add("qs-hidden"), e.onHide(e));
    }
    function S(e) {
      e.disabled || (e.calendarContainer.classList.remove("qs-hidden"), "overlay" === e.defaultView && M(!1, e), D(e), e.onShow(e));
    }
    function M(e, t) {
      var n = t.calendar,
        a = n.querySelector(".qs-overlay"),
        r = a.querySelector(".qs-overlay-year"),
        i = n.querySelector(".qs-controls"),
        o = n.querySelector(".qs-squares");
      e ? (a.classList.add("qs-hidden"), i.classList.remove("qs-blur"), o.classList.remove("qs-blur"), r.value = "") : (a.classList.remove("qs-hidden"), i.classList.add("qs-blur"), o.classList.add("qs-blur"), r.focus());
    }
    function E(e, t, n, a) {
      var r = isNaN(+new Date().setFullYear(t.value || void 0)),
        i = r ? null : t.value;
      if (13 === e.which || 13 === e.keyCode || "click" === e.type) a ? w(null, n, i, a) : r || t.classList.contains("qs-disabled") || w(null, n, i);else if (n.calendar.contains(t)) {
        n.calendar.querySelector(".qs-submit").classList[r ? "add" : "remove"]("qs-disabled");
      }
    }
    function x(e) {
      return {}.toString.call(e);
    }
    function C(e) {
      a.forEach(function (t) {
        t !== e && q(t);
      });
    }
    function L(e) {
      if (!e.__qs_shadow_dom) {
        var t = e.which || e.keyCode,
          n = e.type,
          r = e.target,
          o = r.classList,
          s = a.filter(function (e) {
            return e.calendar.contains(r) || e.el === r;
          })[0],
          l = s && s.calendar.contains(r);
        if (!(s && s.isMobile && s.disableMobile)) if ("click" === n) {
          if (!s) return a.forEach(q);
          if (s.disabled) return;
          var d = s.calendar,
            c = s.calendarContainer,
            h = s.disableYearOverlay,
            f = s.nonInput,
            v = d.querySelector(".qs-overlay-year"),
            y = !!d.querySelector(".qs-hidden"),
            p = d.querySelector(".qs-month-year").contains(r),
            D = r.dataset.monthNum;
          if (s.noPosition && !l) (c.classList.contains("qs-hidden") ? S : q)(s);else if (o.contains("qs-arrow")) w(o, s);else if (p || o.contains("qs-close")) h || M(!y, s);else if (D) E(e, v, s, D);else {
            if (o.contains("qs-disabled")) return;
            if (o.contains("qs-num")) {
              var b = r.textContent,
                g = +r.dataset.direction,
                x = new Date(s.currentYear, s.currentMonth + g, b);
              if (g) {
                s.currentYear = x.getFullYear(), s.currentMonth = x.getMonth(), s.currentMonthName = i[s.currentMonth], u(s);
                for (var L, Y = s.calendar.querySelectorAll('[data-direction="0"]'), j = 0; !L;) {
                  var O = Y[j];
                  O.textContent === b && (L = O), j++;
                }
                r = L;
              }
              return void (+x == +s.dateSelected ? m(r, s, !0) : r.classList.contains("qs-disabled") || m(r, s));
            }
            o.contains("qs-submit") ? E(e, v, s) : f && r === s.el && (S(s), C(s));
          }
        } else if ("focusin" === n && s) S(s), C(s);else if ("keydown" === n && 9 === t && s) q(s);else if ("keydown" === n && s && !s.disabled) {
          var P = !s.calendar.querySelector(".qs-overlay").classList.contains("qs-hidden");
          13 === t && P && l ? E(e, r, s) : 27 === t && P && l && M(!0, s);
        } else if ("input" === n) {
          if (!s || !s.calendar.contains(r)) return;
          var k = s.calendar.querySelector(".qs-submit"),
            N = r.value.split("").reduce(function (e, t) {
              return e || "0" !== t ? e + (t.match(/[0-9]/) ? t : "") : "";
            }, "").slice(0, 4);
          r.value = N, k.classList[4 === N.length ? "remove" : "add"]("qs-disabled");
        }
      }
    }
    function Y(e) {
      L(e), e.__qs_shadow_dom = !0;
    }
    function j(e, t) {
      l.forEach(function (n) {
        e.removeEventListener(n, t);
      });
    }
    function O() {
      S(this);
    }
    function P() {
      q(this);
    }
    function k(e, t) {
      var n = g(e),
        a = this.currentYear,
        r = this.currentMonth,
        i = this.sibling;
      if (null == e) return this.dateSelected = void 0, p(this.el, this, !0), i && (y({
        instance: this,
        deselect: !0
      }), u(i)), u(this), this;
      if (!b(e)) throw new Error("`setDate` needs a JavaScript Date object.");
      if (this.disabledDates[+n] || n < this.minDate || n > this.maxDate) throw new Error("You can't manually set a date that's disabled.");
      this.dateSelected = n, t && (this.currentYear = n.getFullYear(), this.currentMonth = n.getMonth(), this.currentMonthName = this.months[n.getMonth()]), p(this.el, this), i && (y({
        instance: this
      }), u(i));
      var o = a === n.getFullYear() && r === n.getMonth();
      return o || t ? u(this, n) : o || u(this, new Date(a, r, 1)), this;
    }
    function N(e) {
      return I(this, e, !0);
    }
    function _(e) {
      return I(this, e);
    }
    function I(e, t, n) {
      var a = e.dateSelected,
        r = e.first,
        i = e.sibling,
        o = e.minDate,
        s = e.maxDate,
        l = g(t),
        d = n ? "Min" : "Max";
      function c() {
        return "original" + d + "Date";
      }
      function h() {
        return d.toLowerCase() + "Date";
      }
      function f() {
        return "set" + d;
      }
      function v() {
        throw new Error("Out-of-range date passed to " + f());
      }
      if (null == t) e[c()] = void 0, i ? (i[c()] = void 0, n ? (r && !a || !r && !i.dateSelected) && (e.minDate = void 0, i.minDate = void 0) : (r && !i.dateSelected || !r && !a) && (e.maxDate = void 0, i.maxDate = void 0)) : e[h()] = void 0;else {
        if (!b(t)) throw new Error("Invalid date passed to " + f());
        i ? ((r && n && l > (a || s) || r && !n && l < (i.dateSelected || o) || !r && n && l > (i.dateSelected || s) || !r && !n && l < (a || o)) && v(), e[c()] = l, i[c()] = l, (n && (r && !a || !r && !i.dateSelected) || !n && (r && !i.dateSelected || !r && !a)) && (e[h()] = l, i[h()] = l)) : ((n && l > (a || s) || !n && l < (a || o)) && v(), e[h()] = l);
      }
      return i && u(i), u(e), e;
    }
    function A() {
      var e = this.first ? this : this.sibling,
        t = e.sibling;
      return {
        start: e.dateSelected,
        end: t.dateSelected
      };
    }
    function R() {
      var e = this.shadowDom,
        t = this.positionedEl,
        n = this.calendarContainer,
        r = this.sibling,
        i = this;
      this.inlinePosition && (a.some(function (e) {
        return e !== i && e.positionedEl === t;
      }) || t.style.setProperty("position", null));
      n.remove(), a = a.filter(function (e) {
        return e !== i;
      }), r && delete r.sibling, a.length || j(document, L);
      var o = a.some(function (t) {
        return t.shadowDom === e;
      });
      for (var s in e && !o && j(e, Y), this) delete this[s];
      a.length || l.forEach(function (e) {
        document.removeEventListener(e, L);
      });
    }
    function F(e, t) {
      var n = new Date(e);
      if (!b(n)) throw new Error("Invalid date passed to `navigate`");
      this.currentYear = n.getFullYear(), this.currentMonth = n.getMonth(), u(this), t && this.onMonthChange(this);
    }
    function B() {
      var e = !this.calendarContainer.classList.contains("qs-hidden"),
        t = !this.calendarContainer.querySelector(".qs-overlay").classList.contains("qs-hidden");
      e && M(t, this);
    }
    t.default = function (e, t) {
      var n = function (e, t) {
        var n,
          l,
          d = function (e) {
            var t = c(e);
            t.events && (t.events = t.events.reduce(function (e, t) {
              if (!b(t)) throw new Error('"options.events" must only contain valid JavaScript Date objects.');
              return e[+g(t)] = !0, e;
            }, {}));
            ["startDate", "dateSelected", "minDate", "maxDate"].forEach(function (e) {
              var n = t[e];
              if (n && !b(n)) throw new Error('"options.' + e + '" needs to be a valid JavaScript Date object.');
              t[e] = g(n);
            });
            var n = t.position,
              i = t.maxDate,
              l = t.minDate,
              d = t.dateSelected,
              u = t.overlayPlaceholder,
              h = t.overlayButton,
              f = t.startDay,
              v = t.id;
            if (t.startDate = g(t.startDate || d || new Date()), t.disabledDates = (t.disabledDates || []).reduce(function (e, t) {
              var n = +g(t);
              if (!b(t)) throw new Error('You supplied an invalid date to "options.disabledDates".');
              if (n === +g(d)) throw new Error('"disabledDates" cannot contain the same date as "dateSelected".');
              return e[n] = 1, e;
            }, {}), t.hasOwnProperty("id") && null == v) throw new Error("`id` cannot be `null` or `undefined`");
            if (null != v) {
              var m = a.filter(function (e) {
                return e.id === v;
              });
              if (m.length > 1) throw new Error("Only two datepickers can share an id.");
              m.length ? (t.second = !0, t.sibling = m[0]) : t.first = !0;
            }
            var y = ["tr", "tl", "br", "bl", "c"].some(function (e) {
              return n === e;
            });
            if (n && !y) throw new Error('"options.position" must be one of the following: tl, tr, bl, br, or c.');
            function p(e) {
              throw new Error('"dateSelected" in options is ' + (e ? "less" : "greater") + ' than "' + (e || "max") + 'Date".');
            }
            if (t.position = function (e) {
              var t = e[0],
                n = e[1],
                a = {};
              a[o[t]] = 1, n && (a[o[n]] = 1);
              return a;
            }(n || "bl"), i < l) throw new Error('"maxDate" in options is less than "minDate".');
            d && (l > d && p("min"), i < d && p());
            if (["onSelect", "onShow", "onHide", "onMonthChange", "formatter", "disabler"].forEach(function (e) {
              "function" != typeof t[e] && (t[e] = s);
            }), ["customDays", "customMonths", "customOverlayMonths"].forEach(function (e, n) {
              var a = t[e],
                r = n ? 12 : 7;
              if (a) {
                if (!Array.isArray(a) || a.length !== r || a.some(function (e) {
                  return "string" != typeof e;
                })) throw new Error('"' + e + '" must be an array with ' + r + " strings.");
                t[n ? n < 2 ? "months" : "overlayMonths" : "days"] = a;
              }
            }), f && f > 0 && f < 7) {
              var w = (t.customDays || r).slice(),
                D = w.splice(0, f);
              t.customDays = w.concat(D), t.startDay = +f, t.weekendIndices = [w.length - 1, w.length];
            } else t.startDay = 0, t.weekendIndices = [6, 0];
            "string" != typeof u && delete t.overlayPlaceholder;
            "string" != typeof h && delete t.overlayButton;
            var q = t.defaultView;
            if (q && "calendar" !== q && "overlay" !== q) throw new Error('options.defaultView must either be "calendar" or "overlay".');
            return t.defaultView = q || "calendar", t;
          }(t || {
            startDate: g(new Date()),
            position: "bl",
            defaultView: "calendar"
          }),
          u = e;
        if ("string" == typeof u) u = "#" === u[0] ? document.getElementById(u.slice(1)) : document.querySelector(u);else {
          if ("[object ShadowRoot]" === x(u)) throw new Error("Using a shadow DOM as your selector is not supported.");
          for (var h, f = u.parentNode; !h;) {
            var v = x(f);
            "[object HTMLDocument]" === v ? h = !0 : "[object ShadowRoot]" === v ? (h = !0, n = f, l = f.host) : f = f.parentNode;
          }
        }
        if (!u) throw new Error("No selector / element found.");
        if (a.some(function (e) {
          return e.el === u;
        })) throw new Error("A datepicker already exists on that element.");
        var m = u === document.body,
          y = n ? u.parentElement || n : m ? document.body : u.parentElement,
          w = n ? u.parentElement || l : y,
          D = document.createElement("div"),
          q = document.createElement("div");
        D.className = "qs-datepicker-container qs-hidden", q.className = "qs-datepicker";
        var M = {
          shadowDom: n,
          customElement: l,
          positionedEl: w,
          el: u,
          parent: y,
          nonInput: "INPUT" !== u.nodeName,
          noPosition: m,
          position: !m && d.position,
          startDate: d.startDate,
          dateSelected: d.dateSelected,
          disabledDates: d.disabledDates,
          minDate: d.minDate,
          maxDate: d.maxDate,
          noWeekends: !!d.noWeekends,
          weekendIndices: d.weekendIndices,
          calendarContainer: D,
          calendar: q,
          currentMonth: (d.startDate || d.dateSelected).getMonth(),
          currentMonthName: (d.months || i)[(d.startDate || d.dateSelected).getMonth()],
          currentYear: (d.startDate || d.dateSelected).getFullYear(),
          events: d.events || {},
          defaultView: d.defaultView,
          setDate: k,
          remove: R,
          setMin: N,
          setMax: _,
          show: O,
          hide: P,
          navigate: F,
          toggleOverlay: B,
          onSelect: d.onSelect,
          onShow: d.onShow,
          onHide: d.onHide,
          onMonthChange: d.onMonthChange,
          formatter: d.formatter,
          disabler: d.disabler,
          months: d.months || i,
          days: d.customDays || r,
          startDay: d.startDay,
          overlayMonths: d.overlayMonths || (d.months || i).map(function (e) {
            return e.slice(0, 3);
          }),
          overlayPlaceholder: d.overlayPlaceholder || "4-digit year",
          overlayButton: d.overlayButton || "Submit",
          disableYearOverlay: !!d.disableYearOverlay,
          disableMobile: !!d.disableMobile,
          isMobile: "ontouchstart" in window,
          alwaysShow: !!d.alwaysShow,
          id: d.id,
          showAllDates: !!d.showAllDates,
          respectDisabledReadOnly: !!d.respectDisabledReadOnly,
          first: d.first,
          second: d.second
        };
        if (d.sibling) {
          var E = d.sibling,
            C = M,
            L = E.minDate || C.minDate,
            Y = E.maxDate || C.maxDate;
          C.sibling = E, E.sibling = C, E.minDate = L, E.maxDate = Y, C.minDate = L, C.maxDate = Y, E.originalMinDate = L, E.originalMaxDate = Y, C.originalMinDate = L, C.originalMaxDate = Y, E.getRange = A, C.getRange = A;
        }
        d.dateSelected && p(u, M);
        var j = getComputedStyle(w).position;
        m || j && "static" !== j || (M.inlinePosition = !0, w.style.setProperty("position", "relative"));
        var I = a.filter(function (e) {
          return e.positionedEl === M.positionedEl;
        });
        I.some(function (e) {
          return e.inlinePosition;
        }) && (M.inlinePosition = !0, I.forEach(function (e) {
          e.inlinePosition = !0;
        }));
        D.appendChild(q), y.appendChild(D), M.alwaysShow && S(M);
        return M;
      }(e, t);
      if (a.length || d(document), n.shadowDom && (a.some(function (e) {
        return e.shadowDom === n.shadowDom;
      }) || d(n.shadowDom)), a.push(n), n.second) {
        var l = n.sibling;
        y({
          instance: n,
          deselect: !n.dateSelected
        }), y({
          instance: l,
          deselect: !l.dateSelected
        }), u(l);
      }
      return u(n, n.startDate || n.dateSelected), n.alwaysShow && D(n), n;
    };
  }]).default;
});
"use strict";

(function (app, core, common, CONSTANTS) {
  'use strict';

  const {
    KEY_CODES
  } = CONSTANTS;
  const DELAY = 500;
  const CLASSES = {
    FOCUSED: CONSTANTS.CLASSES.IS_FOCUSED,
    HIDDEN: CONSTANTS.CLASSES.U_HIDE,
    ACTIVE: CONSTANTS.CLASSES.IS_ACTIVE
  };
  const LISTBOX_TEMPLATE = 'filters.listbox';

  /**
   * @const {Number} RANDOM_LIMIT - The top end of the random number generator used to produce a unique ID
   */
  const RANDOM_LIMIT = 1000;

  /**
   * Listbox Item
   * @typedef {Object} ListboxItem
   * @property {String} value - The value of the option
   * @property {String} label - The visible label for the option
   */

  /**
   * Listbox Config
   * @typedef {Object} ListboxConfig
   * @property {String} id - A unique identifier for the listbox
   * @property {String} label - An optional label to display above the listbox
   * @property {String} initialLabel - What to display in the listbox button before anything is selected
   * @property {Array} options - An array of ListboxItems, could be empty
   * @property {String} initialSelection - The initially selected item when the listbox is first rendered
   * @property {Function} selectCallback - The callback function for when focus is changed in the listbox
   * @property {String} template - The html template to render the whole listbox
   * @property {Boolean} splitByLetter - If you want the listbox output to be split by first letter
   */

  /**
   * Listbox
   *
   * Based upon https://www.w3.org/TR/wai-aria-practices/examples/listbox/listbox-collapsible.html
   *
   * @constructor
   *
   * @param {HTMLElement} marker - The DOM node to replace with the listbox
   * @param {ListboxConfig} config - Options object
   */
  app.Listbox = function Listbox(marker) {
    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.marker = marker;
    this.value = '';
    this.template = config.template || LISTBOX_TEMPLATE, this.displayConfig = {
      id: config.id || `listbox-${Math.floor(Math.random() * Math.floor(RANDOM_LIMIT))}`,
      label: config.label,
      cssClass: config.cssClass,
      splitByLetter: config.splitByLetter || false
    };
    if (config.options && config.options.length) {
      this.render(config.options, config.initialSelection);
    }
    this.selectCallback = config.selectCallback || function () {}; //eslint-disable-line no-empty-function
  };

  /**
   * Render
   *
   * Compiles the listbox HTML from the template and injects it into the container
   *
   * @param {Array} options - An array of ListboxItems
   * @param {*} initialValue - After the dropdown is rendered, select an initial value
   * @param {Function} callback - Fires after the listbox has renders and passes the listboxNode
   */
  app.Listbox.prototype.render = function render() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let initialValue = arguments.length > 1 ? arguments[1] : undefined;
    let callback = arguments.length > 2 ? arguments[2] : undefined;
    let optionItems = options.map(option => {
      if (typeof option !== 'object') {
        return {
          value: option,
          label: option
        };
      }
      return option;
    });
    let optionsByLetter;
    this.value = options[0] ? options[0].value : '';
    if (this.displayConfig.splitByLetter) {
      optionsByLetter = optionItems.reduce((letters, option) => {
        const firstLetter = _getFirstAlphanumericChar(option.label || option.value).toUpperCase();
        if (!letters.set.includes(firstLetter)) {
          letters.set.push(firstLetter);
        }
        if (letters[firstLetter]) {
          letters[firstLetter].push(option);
        } else {
          letters[firstLetter] = [option];
        }
        return letters;
      }, {
        set: []
      });
      optionsByLetter.set.sort();
    }

    // If the listbox is already rendered, replace the marker back with the container
    if (this.container) {
      common.closeOnOutsideClick.removeElement(this.container);
      this.container.parentElement.replaceChild(this.marker, this.container);
    }
    this.container = app.templating.render({
      ...this.displayConfig,
      options: optionItems,
      optionsByLetter
    }, this.template, true);
    this.marker.parentElement.replaceChild(this.container, this.marker);
    this.button = this.container.querySelector('.js-listbox-button');
    this.buttonLabel = this.container.querySelector('.js-listbox-button-label');
    this.listboxNode = this.container.querySelector('.js-listbox-list');
    this.listboxOptionNodes = this.listboxNode.querySelectorAll('[role="option"]');
    this.nativeSelect = this.container.querySelector('.js-listbox-select');
    if (!this.button || !this.listboxNode) {
      console.warn('[Listbox] No button or listbox nodes found.');
      return;
    }
    this.activeDescendant = this.listboxNode.getAttribute('aria-activedescendant');
    this.keysSoFar = '';
    this.registerEvents();
    if (initialValue) {
      this.setSelectByValue(initialValue);
    }
    if (callback) {
      callback(this.listboxNode);
    }
  };

  /**
   * Register Events
   *
   * Adds the required event listeners to the button and listbox node for
   * click, keyup, blur, keydown and focus.
   */
  app.Listbox.prototype.registerEvents = function registerEvents() {
    this.button.addEventListener('click', this.toggleListbox.bind(this));
    this.button.addEventListener('keyup', this.checkShow.bind(this));
    this.listboxNode.addEventListener('blur', () => {
      this.burred = true;
      this.hideListbox.bind(this);
      setTimeout(() => {
        this.blurred = false;
      }, DELAY);
    });
    this.listboxNode.addEventListener('keydown', this.checkHide.bind(this));
    this.listboxNode.addEventListener('focus', this.setupFocus.bind(this));
    this.listboxNode.addEventListener('keydown', this.checkKeyPress.bind(this));
    this.listboxNode.addEventListener('click', this.checkClickItem.bind(this));
    common.closeOnOutsideClick.addElement(this.container, () => this.hideListbox(), this.container);
    this.nativeSelect.addEventListener('change', this.handleNativeSelect.bind(this));
  };

  /**
   * Check Show
   *
   * Callback function for a keyup listener, works out based on the key
   * pressed whether we should show the listbox.
   *
   * @param {Event} event - KeyUP event object
   */
  app.Listbox.prototype.checkShow = function checkShow(event) {
    const key = event.which || event.keyCode;
    switch (key) {
      case KEY_CODES.ARROW_KEY_UP:
      case KEY_CODES.ARROW_KEY_DOWN:
        event.preventDefault();
        this.showListbox();
        this.checkKeyPress(event);
        break;
      default:
        break;
    }
  };

  /**
   * Check Hide
   *
   * Callback function for a keydown listener, works out based on the key
   * pressed whether we should hide the listbox.
   *
   * @param {Event} event - KeyUP event object
   */
  app.Listbox.prototype.checkHide = function checkHide(event) {
    const key = event.which || event.keyCode;
    switch (key) {
      case KEY_CODES.ENTER:
        event.preventDefault();
        this.selectItem();
        this.hideListbox();
        this.button.focus();
        break;
      case KEY_CODES.ESCAPE:
        event.preventDefault();
        this.hideListbox();
        this.button.focus();
        break;
      default:
        break;
    }
  };

  /**
   * Toggle Listbox
   *
   * Hides or shows the listbox, based on if it's expanded already. Doesn't
   * re-open it if it's only just been blurred.
   *
   */
  app.Listbox.prototype.toggleListbox = function toggleListbox() {
    if (this.expanded) {
      this.hideListbox();
    } else if (!this.blurred) {
      this.showListbox();
    }
  };

  /**
   * Show Listbox
   *
   * Shows the listbox by setting the relvant flags, attributes and classes.
   */
  app.Listbox.prototype.showListbox = function showListbox() {
    this.expanded = true;
    core.style.addClass(this.container, CLASSES.ACTIVE);
    this.button.setAttribute('aria-expanded', 'true');
    this.listboxNode.focus();
  };

  /**
   * Hide Listbox
   *
   * Hides the listbox by removing the relevant flags, attributes and classes.
   */
  app.Listbox.prototype.hideListbox = function hideListbox() {
    this.expanded = false;
    core.style.removeClass(this.container, CLASSES.ACTIVE);
    this.button.removeAttribute('aria-expanded');
  };

  /**
   * Update Button Text
   *
   * Changes the text of the "Button". Used for when a new item is focused.
   *
   * @param {HTMLElement} focusedItem - The newly focused element
   */
  app.Listbox.prototype.updateButtonText = function updateButtonText(focusedItem) {
    this.buttonLabel.textContent = focusedItem.textContent;
  };

  /**
   * Setup Focus
   *
   * If there is no activeDescendant, focus on the first option
   */
  app.Listbox.prototype.setupFocus = function setupFocus() {
    if (this.activeDescendant) {
      return;
    }
    this.focusFirstItem();
  };

  /**
   * Focus First Item
   *
   * Focus on the first option in the listbox
   */
  app.Listbox.prototype.focusFirstItem = function focusFirstItem() {
    const firstItem = this.listboxOptionNodes[0];
    if (firstItem) {
      this.focusItem(firstItem);
    }
  };

  /**
   * Focus Last Item
   *
   * Focus on the last option in the listbox
   */
  app.Listbox.prototype.focusLastItem = function focusLastItem() {
    const itemList = this.listboxOptionNodes;
    if (itemList.length) {
      this.focusItem(itemList[itemList.length - 1]);
    }
  };

  /**
   * Check key press
   *
   * Handle various keyboard controls; UP/DOWN will shift focus; SPACE selects
   * an item.
   *
   * @param {Event} event - The keydown event object.
   */
  app.Listbox.prototype.checkKeyPress = function checkKeyPress(event) {
    const key = event.which || event.keyCode;
    let nextItem = this.container.querySelector(`#${this.activeDescendant}`);
    if (!nextItem) {
      return;
    }
    switch (key) {
      case KEY_CODES.ARROW_KEY_UP:
      case KEY_CODES.ARROW_KEY_DOWN:
        event.preventDefault();
        if (key === KEY_CODES.ARROW_KEY_UP) {
          nextItem = _getPrevOption(nextItem);
        } else {
          nextItem = _getNextOption(nextItem);
        }
        if (nextItem) {
          this.focusItem(nextItem);
        }
        break;
      case KEY_CODES.HOME:
        event.preventDefault();
        this.focusFirstItem();
        break;
      case KEY_CODES.END:
        event.preventDefault();
        this.focusLastItem();
        break;
      case KEY_CODES.SPACE:
        event.preventDefault();
        break;
      default:
        {
          const itemToFocus = this.findItemToFocus(key);
          if (itemToFocus) {
            this.focusItem(itemToFocus);
          }
          break;
        }
    }
  };

  /**
   * Find Item To Focus
   *
   * Takes in a pressed letter key and tally's it with keys pressed recently,
   * then goes and finds items in the options list that match it.
   *
   * @param {String} key - The latest key pressed from event.which || event.keyCode
   * @returns {HTMLElement} - The found matching option
   */
  app.Listbox.prototype.findItemToFocus = function findItemToFocus(key) {
    const itemList = this.listboxOptionNodes;
    const character = String.fromCharCode(key);
    if (!this.keysSoFar) {
      for (let i = 0; i < itemList.length; i++) {
        if (itemList[i].id === this.activeDescendant) {
          this.searchIndex = i;
        }
      }
    }
    this.keysSoFar += character;
    this.clearKeysSoFarAfterDelay();
    let nextMatch = this.findMatchInRange(itemList, this.searchIndex + 1, itemList.length);
    if (!nextMatch) {
      nextMatch = this.findMatchInRange(itemList, 0, this.searchIndex);
    }
    return nextMatch;
  };

  /**
   * Clear Keys So Far After Delay
   *
   * Triggered after a letter key is pressed, after DELEY it will clear stored
   * pressed keys so a new search can start.
   */
  app.Listbox.prototype.clearKeysSoFarAfterDelay = function clearKeysSoFarAfterDelay() {
    if (this.keyClear) {
      clearTimeout(this.keyClear);
      this.keyClear = null;
    }
    this.keyClear = setTimeout(function () {
      this.keysSoFar = '';
      this.keyClear = null;
    }.bind(this), DELAY);
  };

  /**
   * Find Match In Range
   *
   * Given an array or Nodelist, it will look for matches of an elements
   * innerText to the keysSoFar string and return them;
   *
   * @param {Array|NodeList} list - List of elements to check
   * @param {Number} startIndex - The start point in the array to look from
   * @param {Number} endIndex - The end point in the array to look until
   * @returns {Element} A matched html element
   */
  app.Listbox.prototype.findMatchInRange = function findMatchInRange(list, startIndex, endIndex) {
    /** Find the first item starting with the keysSoFar substring, searching in
     *  the specified range of items */
    for (let i = startIndex; i < endIndex; i++) {
      let label = list[i].innerText.trim();
      if (label && label.toUpperCase().indexOf(this.keysSoFar) === 0) {
        return list[i];
      }
    }
    return null;
  };

  /**
   * Check Click Item
   *
   * Callback for when an option is clicked, if it has the rght role then we
   * focus it, hide the listbox and return focus to the button.
   *
   * @param {Event} event - The click event object
   */
  app.Listbox.prototype.checkClickItem = function checkClickItem(event) {
    if (event.target.getAttribute('role') === 'option') {
      this.focusItem(event.target, true);
      this.hideListbox();
      this.button.focus();
    }
  };

  /**
   * Handle Native Select
   *
   * Callback for when an option is selected in the native select field.
   *
   * @param {Event} event - The change event object
   */
  app.Listbox.prototype.handleNativeSelect = function handleNativeSelect(event) {
    const targetValue = event.currentTarget.value ? event.currentTarget.value : '';
    const target = this.container.querySelector(`[data-value="${targetValue}"]`);
    if (target) {
      this.focusItem(target, true);
    }
  };

  /**
   * Set Select By Value
   *
   * Take a passed value, find the target option to select then focus and select it.
   *
   * @param {String|Number} value - The value of the option you want to focus & select
   * @param {Boolean} [fireCallback=false] - Set to True to fire a callback once selected
   * @returns {Boolean} - True if the value was found and selected
   */
  app.Listbox.prototype.setSelectByValue = function setSelectByValue(value) {
    let fireCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (this.listboxNode) {
      const target = this.listboxNode.querySelector(`[data-value="${value}"]`);
      if (target) {
        this.focusItem(target, true, fireCallback);
        this.nativeSelect.value = value;
        return true;
      }
      return false;
    }
    return false;
  };

  /**
   * Defocus Item
   *
   * Defocuses the specified item by removing attributes and classes
   *
   * @param {HTMLElement} element - The element to defocus
   */
  app.Listbox.prototype.defocusItem = function defocusItem(element) {
    if (!element) {
      return;
    }
    core.style.removeClass(element, CLASSES.FOCUSED);
  };

  /**
   * Focus Item
   *
   * Defocuses any previous focused item, then focus on the specified item by
   * setting attributes and classes. Also checks if we need to scroll the
   * listbox so it can be brought into view.
   *
   * @param {HTMLELement} element - The element to focus
   * @param {Boolean} alsoSelect - True if you want to 'select' the item, as well as focus it
   * @param {Boolean} [fireCallback=true] - Set to false to not fire a callback
   */
  app.Listbox.prototype.focusItem = function focusItem(element, alsoSelect) {
    let fireCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    this.defocusItem(this.container.querySelector(`#${this.activeDescendant}`));
    core.style.addClass(element, CLASSES.FOCUSED);
    this.listboxNode.setAttribute('aria-activedescendant', element.id);
    this.activeDescendant = element.id;
    if (this.listboxNode.scrollHeight > this.listboxNode.clientHeight) {
      const scrollBottom = this.listboxNode.clientHeight + this.listboxNode.scrollTop;
      const elementBottom = element.offsetTop + element.offsetHeight;
      if (elementBottom > scrollBottom) {
        this.listboxNode.scrollTop = elementBottom - this.listboxNode.clientHeight;
      } else if (element.offsetTop < this.listboxNode.scrollTop) {
        this.listboxNode.scrollTop = element.offsetTop;
      }
    }
    if (alsoSelect) {
      this.selectItem(element, fireCallback);
    }
  };

  /**
   * Deselect Item
   *
   * "Deselects" an item by removing the aria-selected attribute
   *
   * @param {HTMLELement} element - The element to deselect
   */
  app.Listbox.prototype.deselectItem = function deselectItem(element) {
    if (!element) {
      return;
    }
    element.removeAttribute('aria-selected');
  };

  /**
   * Select Item
   *
   * Select an item by deselecting the current active item, then setting attributes
   * and properties. Then fires off the selection callback.
   *
   * @param {HTMLELement} element - The element to select
   * @param {Boolean} [fireCallback=true] - Set to false to not fire a callback
   */
  app.Listbox.prototype.selectItem = function selectItem(element) {
    let fireCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    let target = element;
    if (!target) {
      target = this.container.querySelector(`#${this.activeDescendant}`);
    }
    this.deselectItem(this.container.querySelector(`#${this.selectedDescendant}`));
    target.setAttribute('aria-selected', 'true');
    this.selectedDescendant = target.id;
    this.updateButtonText(target);
    this.handleSelectChange(target, fireCallback);
  };

  /**
   * Handle Select Change
   *
   * Fires when the selection of the listbox changes, fires off the configured
   * callback when the value changes. Passes through the value and also the
   * listbox item element to the callback.
   *
   * @param {HTML} element - The listbox item that has just been focussed.
   * @param {Boolean} [fireCallback=true] - Set to false to not fire a callback
   */
  app.Listbox.prototype.handleSelectChange = function handleSelectChange(element) {
    let fireCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const value = element.getAttribute('data-value');
    if (value !== this.value) {
      if (fireCallback) {
        this.selectCallback(value, element);
      }
      this.value = value;
      this.nativeSelect.value = value;
    }
  };

  /**
   * Get Next Option
   *
   * Traverses the nextElementSibling of the passed element until it finds an
   * element with a role of option
   *
   * @param {HTMLElement} element - The input element to start from
   * @returns {HTMLElement} - The next found 'option'
   */
  const _getNextOption = element => {
    let nextElement = element.nextElementSibling;
    while (nextElement && (!nextElement.getAttribute('role') || nextElement.getAttribute('role') !== 'option')) {
      nextElement = nextElement.nextElementSibling;
    }
    return nextElement;
  };

  /**
   * Get Previous Option
   *
   * Traverses the previousElementSibling of the passed element until it finds an
   * element with a role of option
   *
   * @param {HTMLElement} element - The input element to start from
   * @returns {HTMLElement} - The prev found 'option'
   */
  const _getPrevOption = element => {
    let prevElement = element.previousElementSibling;
    while (prevElement && (!prevElement.getAttribute('role') || prevElement.getAttribute('role') !== 'option')) {
      prevElement = prevElement.previousElementSibling;
    }
    return prevElement;
  };

  /**
   * Get First Alphanumeric Char
   *
   * Given a string, this gets the first alphanumeric character from the string
   * and returns it
   *
   * @param {String} string - The string to get the first letter of
   * @returns {String} The found first letter
   */
  const _getFirstAlphanumericChar = string => {
    const result = string.match(/[a-zA-Z0-9]/);
    return result !== null ? result[0] : null;
  };
})(PULSE.app, PULSE.core, PULSE.app.common, PULSE.app.common.CONSTANTS);
"use strict";

(function (app, common) {
  'use strict';

  /**
   * Filter
   *
   * Generic Filter class to provide an easier way to connect the various ]
   * elements of a filter with the store. Doesn't handle any UI, just provides
   * various callbacks and methods to interact with the store easily.
   */
  app.Filter = class Filter {
    /**
     * Constructor
     *
     * Preps the config, then waits for redux to be loaded before initialisation
     *
     * @param {String} name - The name of the filter
     * @param {Object} config - Config for the Filter, must include a name
     */
    constructor(name, config) {
      this.name = name;
      this.config = config;

      // Kick off once Redux is loaded
      common.dependency.loaded('redux').then(this.init.bind(this));
    }

    /**
     * Init
     *
     * Fires once redux has loaded. Sets up some watches and creates the
     * filter in the store
     */
    init() {
      const {
        slices,
        watch,
        store
      } = PULSE.app.redux;

      // Setup watch to update the UI when the filter is changed externally
      watch(slices.filters.paths.values.single(this.name), value => {
        this.value = value;
        this.updateUI(value);
      }, true);
      this.create();

      // If this filter has dependencies, then watch the stage for updates to them
      if (this.config.dependency) {
        let dependencies = this.config.dependency;
        if (!Array.isArray(dependencies)) {
          dependencies = [this.config.dependency];
        }
        for (let i = 0; i < dependencies.length; i++) {
          const dependency = dependencies[i];
          watch(slices.filters.paths.stage.single(dependency), value => {
            if (value || value === '') {
              const filtersState = {
                stage: slices.filters.selectors.stage.all(store.getState()),
                values: slices.filters.selectors.values.all(store.getState())
              };
              this.dependencyStaged(value, filtersState, dependency);
            }
          });
        }
      }

      // When resetting trigger a UI update, just incase changes weren't committed
      document.body.addEventListener(common.CONSTANTS.EVENTS.FILTERS.RESET, this.resetUI.bind(this));

      // Watch for updates to the optionsFilter
      watch(slices.filters.paths.config.single.optionsFilter(this.name), list => this.filterOptions(list), true);
    }

    /**
     * Create
     *
     * Creates a new filter in the store, passing in it's name as a key
     * along with its configuration.
     */
    create() {
      const {
        store,
        slices
      } = PULSE.app.redux;

      // Grab initial value from store (in case it's come from the url)
      const stateConfig = slices.filters.selectors.config.single(store.getState(), this.name);
      if (stateConfig) {
        if (stateConfig.initialValue) {
          this.value = stateConfig.initialValue;
        }
        if (stateConfig.filterOptions) {
          this.filterOptions(stateConfig.filterOptions);
        }
      }

      // If value isn't set from stateConfig, set it from instance config
      if (!this.value) {
        this.value = this.config.initialValue ? this.config.initialValue : this.config.defaultValue;
      }

      /**
       * If this filter has dependencies, then check if they have staged
       * values already to apply to the filter
       */
      if (this.config.dependency) {
        let dependencies = this.config.dependency;
        if (!Array.isArray(dependencies)) {
          dependencies = [this.config.dependency];
        }
        for (let i = 0; i < dependencies.length; i++) {
          const dependency = dependencies[i];
          const dependencyValue = slices.filters.selectors.stage.single(store.getState(), dependency);
          if (dependencyValue) {
            const filtersState = {
              stage: slices.filters.selectors.stage.all(store.getState()),
              values: slices.filters.selectors.values.all(store.getState())
            };
            this.dependencyStaged(dependencyValue, filtersState, dependency);
          }
        }
      }

      // After depenendcies are checked, create the filter in the store
      store.dispatch(slices.filters.thunks.create({
        key: this.name,
        config: this.config
      }));
    }

    /**
     * Change
     *
     * Callback method to be used by the UI to update a filter value.
     *
     * @param {*} value - The new value to be set in the store
     */
    change(value) {
      const {
        store,
        slices
      } = PULSE.app.redux;
      store.dispatch(slices.filters.thunks.change({
        key: this.name,
        value
      }));
      this.value = value;
    }

    /**
     * Dependency Staged
     *
     * Fires whenever this filters dependency has a new changed staged. The
     * default version just commits the stage and doesn't do anything. This
     * is designed to be overwritten when extending the class. Make sure in
     * the new method to still fire a change to cause a commit, otherwise
     * the stage will never get committed.
     *
     * @param {*} value - The new value to be set in the store
     * @param {*} filterState - State of both the stage and values of the filtersStore
     */
    dependencyStaged() {
      const {
        store,
        slices
      } = PULSE.app.redux;
      store.dispatch(slices.filters.actions.commit());
    }

    /**
     * Update UI
     *
     * Called whenever the filter is changed outside of the UI. Should
     * return true or false if the value was found and successfully updated.
     * This should be overriden by the when extending the class, since we
     * don't handle an UI here, this always returns false.
     *
     * @returns {Boolean} - Wether the option was found and set correctly.
     */
    updateUI() {
      return false;
    }

    /**
     * Confirm Filters
     *
     * Commits whatever is on the stage when the search/confirm button is
     * clicked.
     *
     * @param {Event} event - Event object
     */
    confirmFilters(event) {
      if (event) {
        event.preventDefault();
      }
      const {
        store,
        slices
      } = PULSE.app.redux;
      if (slices.filters.selectors.initialised(store.getState())) {
        store.dispatch(slices.filters.actions.commit());
      }
    }

    /**
     * Filter Options
     *
     * Called when the fitlerOptions in a filters config is updated.
     * Override when extending the class if you want be able to limit your
     * options in the filter.
     *
     * @param {Array} list - The list of options that you should filter down to
     */
    filterOptions() {
      // Limit your filter options
    }

    /**
     * Reset UI
     *
     * Fires when a "RESET" event is triggered. Selects the filters config
     * and uses the defaultValue set inside of that as a param in a call
     * to updateUI.
     */
    resetUI() {
      const {
        store,
        slices
      } = PULSE.app.redux;
      const config = slices.filters.selectors.config.single(store.getState(), this.name);
      if (config) {
        this.updateUI(config.defaultValue);
      }
    }
  };
})(PULSE.app, PULSE.app.common);
"use strict";

(function (app) {
  'use strict';

  const OBSERVABLE_SELECTOR = '.js-lazy-flag';

  /**
   * Class that loads in images when they become active
   * upon entering the viewport
   *
   * @param {HTMLElement} container the container element of the items that should be observed
   * @constructor
   */
  app.LazyFlag = class LazyFlag {
    constructor(container) {
      this.observerConfig = {
        root: container,
        // default to browser viewport
        rootMargin: '0px',
        threshold: 0.025
      };
      const observableContainers = [...container.querySelectorAll(OBSERVABLE_SELECTOR)];

      // get items unobserved and apply the listeners
      const uninitiatedObservables = this.getUnobservedElements(observableContainers);
      this.setObservableListener(uninitiatedObservables);
    }

    /**
     * Filters the observableContainer list so the items being observed have not been observed before
     * and are the correct markup elements for observing
     *
     * @param {HTMLElement[]} observableContainers - the matching elements that are meant to be observed
     * @return {Array} Filtered array of observable elements
     */
    getUnobservedElements(observableContainers) {
      return observableContainers.filter(observableEl => {
        return observableEl && observableEl.getAttribute('data-picture-in-view') !== 'true';
      });
    }

    /**
     * Listens for elements to become visible within the container
     *
     * @param {HTMLElement[]} observableContainers - the matching elements to apply observer listeners to
     */
    setObservableListener(observableContainers) {
      this.observer = new IntersectionObserver(_onActivate, this.observerConfig);
      observableContainers.forEach(element => {
        this.observer.observe(element);
      });
    }
  };

  /**
   * Callback function from intersection observer
   *
   * `getAttribute` has been used deliberately as it tested faster than
   * `element.dataset.attrName`.
   *
   * @param  {Object[]} entries An Array of IntersectionObserver elements
   */
  const _onActivate = entries => {
    entries.forEach(contentItem => {
      let imgContainer = contentItem.target;
      if (!imgContainer) {
        return;
      }

      // check if the intersection observer's already run on this element
      let hasIntersectedBefore = imgContainer.getAttribute('data-picture-in-view');
      if (contentItem.isIntersecting === false || hasIntersectedBefore === 'true') {
        return;
      }

      // Picture is now in view so add this attr to stop it rendering again.
      imgContainer.setAttribute('data-picture-in-view', 'true');

      // get the picture element/image markup from the comment and add it to the container
      const imageComment = _getFirstCommentNodeChild(imgContainer);
      if (imageComment) {
        imgContainer.insertAdjacentHTML('beforeend', imageComment.textContent.trim());
      }
    });
  };

  /**
   * Returns the first comment node child of an element
   * @param  {HTMLElement} element - the html element to search the child nodes for
   * @return {(Comment|null)}      - the 1st comment node found, or null
   */
  const _getFirstCommentNodeChild = function _getFirstCommentNodeChild(element) {
    for (let i = 0; i < element.childNodes.length; i++) {
      if (element.childNodes[i].nodeType === Node.COMMENT_NODE) {
        return element.childNodes[i];
      }
    }
    return null;
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - The options that power the listbox
   */
  const OPTIONS = [{
    value: '',
    label: PULSE.I18N.lookup('label.filters.all')
  }, {
    value: 'M',
    label: PULSE.I18N.lookup('label.filters.gender.M')
  }, {
    value: 'F',
    label: PULSE.I18N.lookup('label.filters.gender.F')
  }];

  /**
   * Filter - Athlete Gender
   * @extends app.Filter
   */
  app.FilterAthleteGenderWidget = class FilterAthleteGenderWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS[0].value;
      super('gender', {
        defaultValue: defaultValue
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-gender',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.gender'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value ? value : '';
      return this.listbox.setSelectByValue(targetValue);
    }
  };
})(PULSE.app);
"use strict";

(function (app, core) {
  'use strict';

  /**
   * @const {Array} OPTIONS - All pool size options
   */
  const OPTIONS = [{
    value: '',
    label: PULSE.I18N.lookup('label.filters.country.all')
  }];

  /**
   * Filter - Athlete Nationality
   * @extends app.Filter
   */
  app.FilterAthleteNationalityWidget = class FilterAthleteNationalityWidget extends app.Filter {
    /* eslint-disable-line id-length */
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS[0].value;
      super('nationality', {
        defaultValue: defaultValue
      });
      this.value = '';

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-nationality',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.nf'),
        options: OPTIONS
      });
      this.fetchCountries();
    }

    /**
     * Fetch Countries
     *
     * Fire off request to the countries endpoint to get back a list of
     * countries
     */
    fetchCountries() {
      const url = app.common.endpoints.fina.countries.all();
      core.data.request(url, 'GET', this.handleCountriesResponse.bind(this), [app.account]);
    }

    /**
     * Handle Countries Response
     *
     * Callback function for when the countries api returns a list of
     * countries. Checks the data then maps them to an options array and
     * renders them into the listbox.
     *
     * @param {Array} data - Response from countries api
     */
    handleCountriesResponse(data) {
      if (!data || !data.length) {
        console.warn('[Nationality Filter] There was an error fetching the countries list.');
        return;
      }

      // Filter out CLB option
      const filteredCountries = data.filter(country => country.Code !== 'CLB');

      // Model the countries in the countries api response and sort by code
      const countries = filteredCountries.map(country => ({
        value: country.Code,
        label: `${app.templating.render({
          cssClass: 'listbox__flag',
          countryCode: country.Code
        }, 'filters.lazy-flag')} ${country.Code} - ${country.Name}`,
        textLabel: `${country.Code} - ${country.Name}`,
        code: country.Code,
        continent: country.RegionName
      })).sort((a, b) => a.code.localeCompare(b.code));
      this.listbox.render([...OPTIONS, ...countries], this.value, listbox => new app.LazyFlag(listbox));
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      this.value = targetValue;
      return this.listbox.setSelectByValue(targetValue);
    }
  };
})(PULSE.app, PULSE.core);
"use strict";

(function (app, core, CONSTANTS) {
  'use strict';

  const {
    CLASSES
  } = CONSTANTS;

  /**
   * Filter - Athlete Search
   * @extends app.Filter
   */
  app.FilterAthleteSearchWidget = class FilterAthleteSearchWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('name', {
        defaultValue: ''
      });
      this.input = container.querySelector('.js-search-input');
      if (!this.input) {
        return;
      }

      // Input 'input' event
      this.input.addEventListener('input', event => {
        const value = event.target.value;
        super.change(value);
        this.togglePlaceholderLabel(value);
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - True as we can always update the value of the field
     */
    updateUI(value) {
      if (this.input.value !== value) {
        this.input.value = value;
        this.togglePlaceholderLabel(value);
      }
      return true;
    }

    /**
     * Toggle Placeholder Label
     *
     * Given a value, either adds or removes the class to show the
     * placeholder label element.
     *
     * @param {String} value - The value of the input
     */
    togglePlaceholderLabel(value) {
      if (value) {
        core.style.addClass(this.input.parentNode, CLASSES.IS_FOCUSED);
      } else {
        core.style.removeClass(this.input.parentNode, CLASSES.IS_FOCUSED);
      }
    }
  };
})(PULSE.app, PULSE.core, PULSE.app.common.CONSTANTS);
"use strict";

(function (app, core) {
  'use strict';

  /**
   * @const {Array} OPTIONS - All pool size options
   */
  const OPTIONS = [{
    value: '',
    label: PULSE.I18N.lookup('label.filters.country.all')
  }];

  /**
   * Filter - Country Id
   * @extends app.Filter
   */
  app.FilterCompAthleteNfWidget = class FilterCompAthleteNfWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS[0].value;
      super('countryId', {
        defaultValue: defaultValue
      });
      this.value = '';

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-country',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.nf'),
        options: OPTIONS
      });
      this.fetchCountries();
    }

    /**
     * Fetch Countries
     *
     * Fire off request to the countries endpoint to get back a list of
     * countries
     */
    fetchCountries() {
      const url = app.common.endpoints.fina.countries.all();
      core.data.request(url, 'GET', this.handleCountriesResponse.bind(this), [app.account]);
    }

    /**
     * Handle Countries Response
     *
     * Callback function for when the countries api returns a list of
     * countries. Checks the data then maps them to an options array and
     * renders them into the listbox.
     *
     * @param {Array} data - Response from countries api
     */
    handleCountriesResponse(data) {
      if (!data || !data.length) {
        console.warn('[countryId Filter] There was an error fetching the countries list.');
        return;
      }

      // Model the countries in the countries api response and sort by code
      this.countries = data.map(country => ({
        value: country.Id,
        label: `${app.templating.render({
          cssClass: 'listbox__flag',
          countryCode: country.Code
        }, 'filters.lazy-flag')} ${country.Code} - ${country.Name}`,
        textLabel: `${country.Code} - ${country.Name}`,
        code: country.Code,
        continent: country.RegionName
      })).sort((a, b) => a.code.localeCompare(b.code));
      if (this.allowedCountryCodes) {
        this.filterOptions(this.allowedCountryCodes);
      } else {
        this.listbox.render([...OPTIONS, ...this.countries], this.value, listbox => new app.LazyFlag(listbox));
      }
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      this.value = targetValue;
      return this.listbox.setSelectByValue(targetValue);
    }

    /**
     * Filter Options
     *
     * Called when the fitlerOptions in a filters config is updated. Here we
     * limit the options in the listbox to match what is in the config.
     *
     * @param {Array} list - The list of country codes to display in the listbox
     */
    filterOptions(list) {
      if (!list) {
        return;
      }
      if (this.countries) {
        this.allowedCountryCodes = false;
        const filteredCountries = this.countries.filter(country => list.includes(country.code));
        this.listbox.render([...OPTIONS, ...filteredCountries], this.value, listbox => new app.LazyFlag(listbox));
      } else {
        this.allowedCountryCodes = list;
      }
    }
  };
})(PULSE.app, PULSE.core);
"use strict";

(function (app) {
  'use strict';

  const CURRENT_YEAR = dayjs().year();
  const MONTHS = dayjs().localeData().months();
  const OPTIONS = MONTHS.map((month, index) => {
    return {
      value: (index + 1).toString(),
      label: month
    };
  });
  const OPTIONS_WITH_LATEST = [{
    value: 'latest',
    label: PULSE.I18N.lookup('label.filters.latestMonth')
  }, ...OPTIONS];

  /**
   * Filter - Competition Month
   * @extends app.Filter
   */
  app.FilterCompMonthWidget = class FilterCompMonthWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('month', {
        defaultValue: OPTIONS_WITH_LATEST[0].value,
        dependency: 'year'
      });
      this.latestVisible = true;

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-comp-month',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.compmonth'),
        options: OPTIONS_WITH_LATEST
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      if (value === 'latest' && !this.latestVisible) {
        this.listbox.render(OPTIONS_WITH_LATEST, value);
        return true;
      }
      return this.listbox.setSelectByValue(value);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {*} value - The staged value of our dependency
     */
    dependencyStaged(value) {
      if (value === CURRENT_YEAR) {
        this.latestVisible = true;
        this.listbox.render(OPTIONS_WITH_LATEST);
        super.change('latest');
      } else {
        this.latestVisible = false;
        this.listbox.render(OPTIONS);
        super.change('1');
      }
    }
  };
})(PULSE.app);
"use strict";

(function (app, core) {
  'use strict';

  const {
    CLASSES,
    COMP_TYPES
  } = app.common.CONSTANTS;

  /**
   * @const {Array} OPTIONS - All comp type options, manually ordered by orderIndex values from FINA API
   */
  const OPTIONS = [{
    value: COMP_TYPES.WORLD_CHAMPIONSHIPS,
    label: PULSE.I18N.lookup('label.filters.compType.worldChampionships'),
    orderIndex: 2
  }, {
    value: COMP_TYPES.WORLD_SWIMMING_CHAMPIONSHIPS_25M,
    label: PULSE.I18N.lookup('label.filters.compType.worldSwimmingChampionships25m'),
    orderIndex: 3
  }, {
    value: COMP_TYPES.CHAMPIONS_SWIM_SERIES,
    label: PULSE.I18N.lookup('label.filters.compType.championsSwimSeries'),
    orderIndex: 4
  }, {
    value: COMP_TYPES.SWIMMING_WORLD_CUP,
    label: PULSE.I18N.lookup('label.filters.compType.swimmingWorldCup'),
    orderIndex: 5
  }, {
    value: COMP_TYPES.WORLD_JUNIOR_SWIMMING_CHAMPIONSHIPS,
    label: PULSE.I18N.lookup('label.filters.compType.worldJuniorSwimmingChampionships'),
    orderIndex: 7
  }];

  /**
   * Filter - Comp Type
   * @extends app.Filter
   */
  app.FilterCompTypeWidget = class FilterCompTypeWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('eventTypeId', {
        defaultValue: '',
        dependency: 'recordCode'
      });
      this.filterItemEle = container.parentElement;

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-comp-type',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.compType'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      if (targetValue) {
        core.style.removeClass(this.filterItemEle, CLASSES.U_HIDE);
      }
      return this.listbox.setSelectByValue(targetValue);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {*} recordCode - The staged value of our dependency
     */
    dependencyStaged(recordCode) {
      if (recordCode === 'MR') {
        const newValue = this.value || OPTIONS[0].value;
        this.listbox.setSelectByValue(newValue);
        super.change(newValue);
        core.style.removeClass(this.filterItemEle, CLASSES.U_HIDE);
      } else {
        super.change('');
        core.style.addClass(this.filterItemEle, CLASSES.U_HIDE);
      }
    }
  };
})(PULSE.app, PULSE.core);
"use strict";

(function (app, common) {
  'use strict';

  const OLDEST_YEAR = 1908;

  /**
   * Filter - Competition Year
   * @extends app.Filter
   */
  app.FilterCompYearWidget = class FilterCompYearWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const latestYear = Number(container.getAttribute('data-latest-year'));
      const currentYear = dayjs().year();
      const GROUP_OPTIONS = {
        FINA: {
          options: common.date.getArrayOfYears(OLDEST_YEAR, latestYear),
          defaultYear: latestYear && !isNaN(latestYear) && latestYear < currentYear ? latestYear : currentYear
        },
        OTHER: {
          options: common.date.getArrayOfYears(OLDEST_YEAR),
          defaultYear: currentYear
        }
      };
      super('year', {
        defaultValue: GROUP_OPTIONS.FINA.defaultYear,
        dependency: 'group'
      });
      this.groupOptions = GROUP_OPTIONS;

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-comp-year',
        selectCallback: value => super.change(Number(value)),
        label: PULSE.I18N.lookup('label.filters.compyear'),
        options: GROUP_OPTIONS.FINA.options,
        initialSelection: GROUP_OPTIONS.FINA.defaultYear
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {*} value - The staged value of our dependency
     */
    dependencyStaged(value) {
      this.updateListboxOptions(this.groupOptions[value].options);
    }

    /**
     * Update Listbox Options
     *
     * Take a set of options, look to see if the current value of the filter
     * is in those options, if it is, then render the listbox and pick that
     * value. Otherwise, re-render the filter picking the first item as the
     * selected value and also fire a change call for the store.
     *
     * @param {Array} options - Options array of value/label objects
     */
    updateListboxOptions(options) {
      if (options.find(option => option === this.value) ? true : false) {
        this.listbox.render(options, this.value);
        super.confirmFilters();
      } else {
        this.listbox.render(options);
        super.change(options[0]);
      }
    }
  };
})(PULSE.app, PULSE.app.common);
"use strict";

(function (app, core) {
  'use strict';

  /**
   * @const {Array} OPTIONS - All pool size options
   */
  const OPTIONS = [{
    value: '',
    label: PULSE.I18N.lookup('label.filters.country.all')
  }];

  /**
   * Filter - Country Id
   * @extends app.Filter
   */
  app.FilterCountryIdWidget = class FilterCountryIdWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS[0].value;
      const initialValue = container.getAttribute('data-initial-value');
      super('countryId', {
        defaultValue: defaultValue,
        initialValue: initialValue ? initialValue : defaultValue,
        dependency: 'regionId'
      });
      this.value = '';
      this.activeContinentFilter = '';

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-country',
        selectCallback: value => {
          this.value = value;
          super.change(value);
        },
        label: PULSE.I18N.lookup('label.filters.country'),
        options: OPTIONS,
        cssClass: 'listbox--wide'
      });
      this.fetchCountries();
    }

    /**
     * Fetch Countries
     *
     * Fire off request to the countries endpoint to get back a list of
     * countries
     */
    fetchCountries() {
      const url = app.common.endpoints.fina.countries.all();
      core.data.request(url, 'GET', this.handleCountriesResponse.bind(this), [app.account]);
    }

    /**
     * Handle Countries Response
     *
     * Callback function for when the countries api returns a list of
     * countries. Checks the data then maps them to an options array and
     * renders them into the listbox.
     *
     * @param {Array} data - Response from countries api
     */
    handleCountriesResponse(data) {
      if (!data || !data.length) {
        console.warn('[countryId Filter] There was an error fetching the countries list.');
        return;
      }

      // Model the countries in the countries api response
      const modelledCountries = data.map(country => ({
        value: country.Id,
        label: `${app.templating.render({
          cssClass: 'listbox__flag',
          countryCode: country.Code
        }, 'filters.lazy-flag')} ${country.Code} - ${country.Name}`,
        textLabel: `${country.Code} - ${country.Name}`,
        code: country.Code,
        continent: country.RegionName
      }));

      /* Sort the coutries by Country Code and add the them to the window
       * so we can use the country names from the response to populate the
       * title in swimming-rankings.js */
      window.COUNTRIES = modelledCountries.sort((a, b) => a.code.localeCompare(b.code));
      app.common.fireEvent(app.common.CONSTANTS.EVENTS.COUNTRIES.LOADED);
      const {
        slices,
        store
      } = PULSE.app.redux;
      const contientFilter = slices.filters.selectors.values.single(store.getState(), 'regionId');
      this.filterCountryList(contientFilter);
    }

    /**
     * Filter Country List
     *
     * Given a continent, filter the country list down to just countries in
     * that continent. If "All" is passed a full list of countries is shown.
     *
     * @param {String} continent - The name of the continent
     */
    filterCountryList(continent) {
      let countryList = [];
      if (continent && continent !== 'all') {
        this.activeContinentFilter = continent;
        countryList = window.COUNTRIES.filter(country => country.continent.toLowerCase() === continent.toLowerCase());
      } else {
        this.activeContinentFilter = '';
        countryList = window.COUNTRIES;
      }
      this.listbox.render([...OPTIONS, ...countryList], this.value, this.renderFlags.bind(this));
    }

    /**
     * Render Flags
     *
     * Callback fired once the listbox has rendered, this kicks of the lazy
     * loading of flags.
     *
     * @param {HTMLElement} listbox - The listbox node
     */
    renderFlags(listbox) {
      new app.LazyFlag(listbox);
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      this.value = targetValue;
      return this.listbox.setSelectByValue(targetValue);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {String} continent - The staged value of our dependency
     */
    dependencyStaged(continent) {
      if (continent !== this.activeContinentFilter) {
        if (window.COUNTRIES) {
          this.filterCountryList(continent);
          super.change(OPTIONS[0].value);
        } else {
          this.activeContinentFilter = continent;
        }
      }
    }
  };
})(PULSE.app, PULSE.core);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - The options that power the listbox
   */
  const OPTIONS = [{
    value: 'ALL',
    label: PULSE.I18N.lookup('label.filters.all')
  }, {
    value: 'SW',
    label: PULSE.I18N.lookup('label.filters.discipline.swimming')
  }, {
    value: 'WP',
    label: PULSE.I18N.lookup('label.filters.discipline.waterpolo')
  }, {
    value: 'DV',
    label: PULSE.I18N.lookup('label.filters.discipline.diving')
  }, {
    value: 'AS',
    label: PULSE.I18N.lookup('label.filters.discipline.artisticswimming')
  }, {
    value: 'OW',
    label: PULSE.I18N.lookup('label.filters.discipline.openwater')
  }, {
    value: 'HD',
    label: PULSE.I18N.lookup('label.filters.discipline.highdiving')
  }];

  /**
   * Filter - Development Discipline
   * @extends app.Filter
   */
  app.FilterDevelopmentDisciplineWidget = class FilterDevelopmentDisciplineWidget extends app.Filter {
    /* eslint-disable-line id-length */
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('discipline', {
        defaultValue: OPTIONS[0].value
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-discipline',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.discipline'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      return this.listbox.setSelectByValue(targetValue);
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Object} ALL - An ALL option to automatically add to the dropdown options
   */
  const ALL = {
    value: 'ALL',
    label: PULSE.I18N.lookup('label.filters.all')
  };

  /**
   * Filter - Development (Calendar) Language
   * @extends app.Filter
   */
  app.FilterDevelopmentLanguageWidget = class FilterDevelopmentLanguageWidget extends app.Filter {
    /* eslint-disable-line id-length */
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const attributeOptions = container.getAttribute('data-options').replace(' ', '').split(',');
      const options = [ALL, ...attributeOptions];
      const defaultLanguageAttribute = container.getAttribute('data-default');
      let defaultValue = options[0].value;

      // Check default attribute is in the list of options and if so set it
      if (defaultLanguageAttribute && options.includes(defaultLanguageAttribute)) {
        defaultValue = defaultLanguageAttribute;
      }
      super('lang', {
        defaultValue
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-development-language',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.language'),
        options: options
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      return this.listbox.setSelectByValue(targetValue);
    }
  };
})(PULSE.app, PULSE.core);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - All dropdown options
   */
  const OPTIONS = [{
    value: 'ALL',
    label: PULSE.I18N.lookup('label.filters.all')
  }, {
    value: 'AFRICA',
    label: PULSE.I18N.lookup('label.filters.continent.africa')
  }, {
    value: 'AMERICAS',
    label: PULSE.I18N.lookup('label.filters.continent.americas')
  }, {
    value: 'ASIA',
    label: PULSE.I18N.lookup('label.filters.continent.asia')
  }, {
    value: 'EUROPE',
    label: PULSE.I18N.lookup('label.filters.continent.europe')
  }, {
    value: 'OCEANIA',
    label: PULSE.I18N.lookup('label.filters.continent.oceania')
  }];

  /**
   * Filter - Development (Calendar) Region
   * @extends app.Filter
   */
  app.FilterDevelopmentRegionWidget = class FilterDevelopmentRegionWidget extends app.Filter {
    /* eslint-disable-line id-length */
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('region', {
        defaultValue: OPTIONS[0].value
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-development-region',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.developmentContinent'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      return this.listbox.setSelectByValue(targetValue);
    }
  };
})(PULSE.app, PULSE.core);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - The options that power the listbox
   */
  const OPTIONS = [{
    value: '',
    label: PULSE.I18N.lookup('label.filters.all')
  }];

  /**
   * @const {Object} DISC_OPTIONS - The list of disciplines options stored by key
   */
  /* eslint-disable id-length */
  const DISC_OPTIONS = {
    SW: {
      value: 'SW',
      label: PULSE.I18N.lookup('label.filters.discipline.swimming'),
      priority: 1
    },
    WP: {
      value: 'WP',
      label: PULSE.I18N.lookup('label.filters.discipline.waterpolo'),
      priority: 2
    },
    DV: {
      value: 'DV',
      label: PULSE.I18N.lookup('label.filters.discipline.diving'),
      priority: 3
    },
    SY: {
      value: 'SY',
      label: PULSE.I18N.lookup('label.filters.discipline.artisticswimming'),
      priority: 4
    },
    OW: {
      value: 'OW',
      label: PULSE.I18N.lookup('label.filters.discipline.openwater'),
      priority: 5
    },
    HD: {
      value: 'HD',
      label: PULSE.I18N.lookup('label.filters.discipline.highdiving'),
      priority: 6
    }
    /* eslint-enable id-length */
  };
  const ALL_DISCS = ['SW', 'WP', 'DV', 'SY', 'OW', 'HD'];

  /**
   * Filter - Discipline Dropdown
   * @extends app.Filter
   */
  app.FilterDisciplineDropdownWidget = class FilterDisciplineDropdownWidget extends app.Filter {
    /* eslint-disable-line id-length */
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      let dropdownOptions = [...OPTIONS];
      const optionsAttribute = container.getAttribute('data-options');
      const initialValue = container.getAttribute('data-initial-value');

      // If there is an attribute, only show those discs, otherwise grab em all
      if (optionsAttribute) {
        const attributeArray = optionsAttribute.split(',');
        const disciplines = attributeArray.map(disc => DISC_OPTIONS[disc]);
        dropdownOptions.push(...disciplines.sort((a, b) => {
          return a.priority - b.priority;
        }));
      } else {
        dropdownOptions.push(...ALL_DISCS.map(disc => DISC_OPTIONS[disc]));
      }
      const defaultValue = initialValue ? initialValue : dropdownOptions[0].value;
      super('discipline', {
        defaultValue: defaultValue
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-discipline',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.discipline'),
        options: dropdownOptions
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      return this.listbox.setSelectByValue(targetValue);
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * Filter - Discipline
   * @extends app.Filter
   */
  app.FilterDisciplineWidget = class FilterDisciplineWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and finds all the radio
     * inputs and attachs the eventListeners.
     *
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const initialEle = container.querySelector(':checked');
      const defaultValue = container.getAttribute('data-default-value') || '';
      super('disciplines', {
        defaultValue: defaultValue,
        initialValue: initialEle ? initialEle.value : ''
      });
      this.container = container;
      const inputs = [].slice.call(this.container.querySelectorAll('.js-filter-input'));
      inputs.forEach(element => element.addEventListener('change', this.inputChanged.bind(this)));
    }

    /**
     * Input Changed
     *
     * Callback for when a change event is fired on one of the radio buttons.
     * Calls the change method from the super.
     *
     * @param {Event} event - change event
     */
    inputChanged(event) {
      super.change(event.target.value);
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value ? value : '';
      const target = this.container.querySelector(`[value="${targetValue}"]`);
      if (target) {
        target.checked = true;
        return true;
      }
      return false;
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} MF_OPTIONS - The male & female options that power the listbox
   */
  const MF_OPTIONS = [{
    value: 50,
    label: PULSE.I18N.lookup('label.filters.distance.50')
  }, {
    value: 100,
    label: PULSE.I18N.lookup('label.filters.distance.100')
  }, {
    value: 200,
    label: PULSE.I18N.lookup('label.filters.distance.200')
  }, {
    value: 400,
    label: PULSE.I18N.lookup('label.filters.distance.400')
  }, {
    value: 800,
    label: PULSE.I18N.lookup('label.filters.distance.800')
  }, {
    value: 1500,
    label: PULSE.I18N.lookup('label.filters.distance.1500')
  }];

  /**
   * @const {Array} MX_OPTIONS - The mixed geneder options that power the listbox
   */
  const MX_OPTIONS = [{
    value: 50,
    label: PULSE.I18N.lookup('label.filters.distance.50')
  }, {
    value: 100,
    label: PULSE.I18N.lookup('label.filters.distance.100')
  }];
  const OPTIONS = {
    F: MF_OPTIONS,
    M: MF_OPTIONS,
    X: MX_OPTIONS
  };

  /**
   * Filter - Distance
   * @extends app.Filter
   */
  app.FilterDistanceWidget = class FilterDistanceWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS.F[0].value;
      super('distance', {
        defaultValue,
        dependency: 'gender'
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-distance',
        selectCallback: value => super.change(Number(value)),
        label: PULSE.I18N.lookup('label.filters.distance'),
        options: MF_OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {*} value - The staged value of our dependency
     */
    dependencyStaged(value) {
      this.updateListboxOptions(OPTIONS[value]);
    }

    /**
     * Update Listbox Options
     *
     * Take a set of options, look to see if the current value of the filter
     * is in those options, if it is, then render the listbox and pick that
     * value. Otherwise, re-render the filter picking the first item as the
     * selected value and also fire a change call for the store.
     *
     * @param {Array} options - Options array of value/label objects
     */
    updateListboxOptions(options) {
      if (options.find(option => option.value === this.value) ? true : false) {
        this.listbox.render(options, this.value);
      } else {
        this.listbox.render(options);
        super.change(options[0].value);
      }
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  const OPTIONS = [{
    value: 3,
    label: PULSE.I18N.lookup('label.filters.diveHeight.3')
  }, {
    value: 10,
    label: PULSE.I18N.lookup('label.filters.diveHeight.10')
  }];

  /**
   * Filter - Diving Distance Filter
   * @extends app.Filter
   */
  app.FilterDiveHeightWidget = class FilterDiveHeightWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('height', {
        defaultValue: OPTIONS[0].value
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-dive-height',
        selectCallback: value => super.change(Number(value)),
        label: PULSE.I18N.lookup('label.filters.diveHeight'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  const OPTIONS = [{
    value: 'F',
    label: PULSE.I18N.lookup('label.filters.diveEvent.F')
  }, {
    value: 'FS',
    label: PULSE.I18N.lookup('label.filters.diveEvent.FS')
  }, {
    value: 'M',
    label: PULSE.I18N.lookup('label.filters.diveEvent.M')
  }, {
    value: 'MS',
    label: PULSE.I18N.lookup('label.filters.diveEvent.MS')
  }, {
    value: 'XS',
    label: PULSE.I18N.lookup('label.filters.diveEvent.XS')
  }];

  /**
   * Filter - Diving Event Filter
   * @extends app.Filter
   */
  app.FilterDiveEventWidget = class FilterDiveEventWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('event', {
        defaultValue: OPTIONS[0].value
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-dive-event',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.diveEvent'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  const API_DATE_FORMAT = 'MM/DD/YYYY';
  const DISPLAY_DATE_FORMAT = 'DD/MM/YYYY';
  const INPUT_DATE_FORMAT = 'YYYY-MM-DD';

  /**
   * Filter - End Date
   * @extends app.Filter
   */
  app.FilterEndDateWidget = class FilterEndDateWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('endDate', {
        defaultValue: '',
        dependency: ['year', 'startDate']
      });
      const datePickerButton = container.querySelector('.js-date-picker');
      this.datePickerValue = container.querySelector('.js-date-picker-value');
      this.datePickerInput = container.querySelector('.js-date-picker-input');
      this.datePicker = datepicker(datePickerButton, {
        onSelect: (instance, date) => {
          this.setDate(date);
          const dateDayjs = dayjs(date);
          this.datePickerValue.innerHTML = dateDayjs.format(DISPLAY_DATE_FORMAT);
        },
        position: 'br' // Position date picker bottom right
      });
      this.datePickerInput.addEventListener('blur', event => {
        const valueDayjs = dayjs(event.target.value);
        this.datePicker.setDate(valueDayjs.toDate(), true);
        super.change(valueDayjs.format(API_DATE_FORMAT));
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      if (value) {
        this.datePicker.setDate(new Date(value), true);
        this.datePickerValue.innerHTML = dayjs(value).format(DISPLAY_DATE_FORMAT);
        this.datePickerInput.value = dayjs(value).format(INPUT_DATE_FORMAT);
      } else {
        this.datePicker.setDate();
        this.datePickerValue.innerHTML = '';
        this.datePickerInput.value = '';
      }
      return true;
    }

    /**
     * Set Min From Date
     *
     * Given a date, update both the datepicker and date field to have min
     * limits so the user can't pick dates before the date they've picked
     *
     * @param {Number} date - The date to limit by
     */
    setMinFromDate(date) {
      if (date) {
        const dateDayjs = dayjs(date);
        this.datePickerInput.min = dateDayjs.format(INPUT_DATE_FORMAT);
        /** See if mins and maxes can be set around current date, if not
         * catch the error and unset the date and try again */
        try {
          this.datePicker.setMin(dateDayjs.toDate());
        } catch (error) {
          this.updateUI();
          this.datePicker.setMin(dateDayjs.toDate());
        }
        this.datePicker.navigate(dateDayjs.toDate());
      } else {
        this.datePicker.setMin();
        this.datePickerInput.min = '';
      }
    }

    /**
     * Set Max From Year
     *
     * Given a year, update both the datepicker and date field to have max
     * limits so the user can't pick dates outside the year they've picked.
     *
     * @param {Number} year - The year to limit by
     */
    setMaxFromYear(year) {
      if (year) {
        const dateDayjs = dayjs(new Date(year, 11, 31)); //eslint-disable-line no-magic-numbers
        this.datePickerInput.max = dateDayjs.format(INPUT_DATE_FORMAT);
        /** See if mins and maxes can be set around current date, if not
         * catch the error and unset the date and try again */
        try {
          this.datePicker.setMax(dateDayjs.toDate());
        } catch (error) {
          this.updateUI();
          this.datePicker.setMax(dateDayjs.toDate());
        }
      } else {
        this.datePicker.setMax();
        this.datePickerInput.max = '';
      }
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {String} dependencyValue - The staged value of our dependency
     * @param {Object} filterState - The current filterState
     * @param {String} dependencyKey - The key of our staged depdency
     */
    dependencyStaged(dependencyValue, filterState, dependencyKey) {
      this.setMinFromDate();
      this.setMaxFromYear();
      if (dependencyKey === 'year' && dependencyValue && dependencyValue !== 'all') {
        this.setMinFromDate(new Date(dependencyValue, 0, 1));
        this.setMaxFromYear(dependencyValue);
        this.setDate(this.datePicker.dateSelected);
      } else if (dependencyKey === 'startDate' && dependencyValue) {
        this.setMinFromDate(dependencyValue);
        const currentYear = filterState.stage.year || filterState.values.year;
        if (currentYear && currentYear !== 'all') {
          this.setMaxFromYear(currentYear);
        }
        this.setDate(this.datePicker.dateSelected);
      }
    }

    /**
     * Set Date
     *
     * Checks to see if a date is present and sets it. If the date is false
     * then instead we set an empty string in the store.
     *
     * @param {Date} date - A JS Date instance
     */
    setDate(date) {
      if (date) {
        const dateDayjs = dayjs(date);
        super.change(dateDayjs.format(API_DATE_FORMAT));
        return;
      }
      super.change('');
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - All pool size options
   */
  const OPTIONS = [{
    value: '',
    label: PULSE.I18N.lookup('label.filters.eventCountry.total')
  }];

  /**
   * Filter - Country Id
   * @extends app.Filter
   */
  app.FilterEventCountryWidget = class FilterEventCountryWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS[0].value;
      const initialValue = container.getAttribute('data-initial-value');
      super('eventCountry', {
        defaultValue: defaultValue,
        initialValue: initialValue ? initialValue : defaultValue
      });
      this.value = '';
      this.activeContinentFilter = '';

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-event-country',
        selectCallback: value => {
          this.value = value;
          super.change(value);
        },
        label: PULSE.I18N.lookup('label.filters.eventCountry'),
        options: OPTIONS,
        cssClass: 'listbox--wide listbox--event-countries'
      });

      // Waits on the dispatch for request to events info being modeled for the table before building the filter
      document.addEventListener('clustersModeled', event => this.handleCountriesResponse(event.detail));
    }

    /**
     * Handle Countries Response
     *
     * Callback function for when the countries api returns a list of
     * countries. Checks the data then maps them to an options array and
     * renders them into the listbox.
     *
     * @param {Array} data - Response from countries api
     */
    handleCountriesResponse(data) {
      if (!data || !data.length) {
        console.warn('[countryId Filter] There was an error fetching the countries list.');
        return;
      }
      // Model the countries in the countries api response
      const modelledCountries = data.map(country => ({
        value: country.Id,
        label: `${app.templating.render({
          cssClass: 'listbox__flag',
          countryCode: country.events[0].EventCountryCode
        }, 'filters.lazy-flag')} ${country.events[0].EventCity}`,
        textLabel: country.events[0].EventCity,
        code: country.events[0].EventCountryCode,
        orderIndex: country.OrderIndex
      }));

      // Sort the coutries by event meet order and add them to the window
      window.COUNTRIES = modelledCountries.sort((a, b) => a.orderIndex - b.orderIndex);
      this.listbox.render([...OPTIONS, ...window.COUNTRIES], this.value, this.renderFlags.bind(this));
    }

    /**
     * Filter Country List
     *
     * Given a continent, filter the country list down to just countries in
     * that continent. If "All" is passed a full list of countries is shown.
     *
     * @param {String} continent - The name of the continent
     */
    filterCountryList(continent) {
      let countryList = [];
      if (continent && continent !== 'all') {
        this.activeContinentFilter = continent;
        countryList = window.COUNTRIES.filter(country => country.continent.toLowerCase() === continent.toLowerCase());
      } else {
        this.activeContinentFilter = '';
        countryList = window.COUNTRIES;
      }
      this.listbox.render([...OPTIONS, ...countryList], this.value, this.renderFlags.bind(this));
    }

    /**
     * Render Flags
     *
     * Callback fired once the listbox has rendered, this kicks of the lazy
     * loading of flags.
     *
     * @param {HTMLElement} listbox - The listbox node
     */
    renderFlags(listbox) {
      new app.LazyFlag(listbox);
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      this.value = targetValue;
      return this.listbox.setSelectByValue(targetValue);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {String} continent - The staged value of our dependency
     */
    dependencyStaged(continent) {
      if (continent !== this.activeContinentFilter) {
        if (window.COUNTRIES) {
          this.filterCountryList(continent);
          super.change(OPTIONS[0].value);
        } else {
          this.activeContinentFilter = continent;
        }
      }
    }
  };
})(PULSE.app, PULSE.core);
"use strict";

(function (app, core) {
  'use strict';

  /**
   * @const {Array} OPTIONS - All pool size options
   */
  const OPTIONS = [{
    value: '',
    label: PULSE.I18N.lookup('label.filters.country.all')
  }];

  /**
   * Filter - Fed Country
   * @extends app.Filter
   */
  app.FilterFedCountryWidget = class FilterFedCountryWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS[0].value;
      super('country', {
        defaultValue: defaultValue,
        dependency: 'region'
      });
      this.value = '';
      this.activeContinentFilter = '';

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-country',
        selectCallback: value => {
          this.value = value;
          super.change(value);
        },
        label: PULSE.I18N.lookup('label.filters.fedCountry'),
        options: OPTIONS
      });
      this.fetchCountries();
    }

    /**
     * Fetch Countries
     *
     * Fire off request to the countries endpoint to get back a list of
     * countries
     */
    fetchCountries() {
      const url = app.common.endpoints.fina.countries.all();
      core.data.request(url, 'GET', this.handleCountriesResponse.bind(this), [app.account]);
    }

    /**
     * Handle Countries Response
     *
     * Callback function for when the countries api returns a list of
     * countries. Checks the data then maps them to an options array and
     * renders them into the listbox.
     *
     * @param {Array} data - Response from countries api
     */
    handleCountriesResponse(data) {
      if (!data || !data.length) {
        console.warn('[Country Filter] There was an error fetching the countries list.');
        return;
      }

      // Model the countries in the countries api response
      this.countries = data.map(country => ({
        value: country.Code,
        label: `${app.templating.render({
          cssClass: 'listbox__flag',
          countryCode: country.Code
        }, 'filters.lazy-flag')} ${country.Code} - ${country.Name}`,
        textLabel: `${country.Code} - ${country.Name}`,
        code: country.Code,
        continent: country.RegionName
      })).sort((a, b) => a.code.localeCompare(b.code));
      const {
        slices,
        store
      } = PULSE.app.redux;
      const continentFilter = slices.filters.selectors.values.single(store.getState(), 'region');
      this.filterByContinent(continentFilter);
    }

    /**
     * Filter By Countinent
     *
     * Given a continent, filter the country list down to just countries in
     * that continent. If "All" is passed a full list of countries is shown.
     *
     * @param {String} continent - The name of the continent
     */
    filterByContinent(continent) {
      let countriesWithFeds = this.countries;
      if (this.allowedCountryCodes) {
        countriesWithFeds = this.countries.filter(country => this.allowedCountryCodes.includes(country.code));
      }
      let countryList = [];
      if (continent && continent !== 'all') {
        this.activeContinentFilter = continent;
        countryList = countriesWithFeds.filter(country => country.continent.toLowerCase() === continent.toLowerCase());
      } else {
        this.activeContinentFilter = '';
        countryList = countriesWithFeds;
      }
      this.listbox.render([...OPTIONS, ...countryList], this.value, this.renderFlags.bind(this));
    }

    /**
     * Filter Options
     *
     * Called when the fitlerOptions in a filters config is updated. Here we
     * add prop to hold all the valid country codes
     *
     * @param {Array} list - The list of country codes to display in the listbox
     */
    filterOptions(list) {
      if (!list) {
        return;
      }
      this.allowedCountryCodes = list;
      if (this.countries) {
        this.filterByContinent(this.activeContinentFilter);
      }
    }

    /**
     * Render Flags
     *
     * Callback fired once the listbox has rendered, this kicks of the lazy
     * loading of flags.
     *
     * @param {HTMLElement} listbox - The listbox node
     */
    renderFlags(listbox) {
      new app.LazyFlag(listbox);
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      this.value = targetValue;
      return this.listbox.setSelectByValue(targetValue);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {String} continent - The staged value of our dependency
     */
    dependencyStaged(continent) {
      if (continent !== this.activeContinentFilter) {
        if (this.countries) {
          this.filterByContinent(continent);
          super.change(OPTIONS[0].value);
        } else {
          this.activeContinentFilter = continent;
        }
      }
    }
  };
})(PULSE.app, PULSE.core);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - All pool size options
   */
  const OPTIONS = [{
    value: 'all',
    label: PULSE.I18N.lookup('label.filters.continent.all')
  }, {
    value: 'AFRICA',
    label: PULSE.I18N.lookup('label.filters.continent.africa')
  }, {
    value: 'AMERICAS',
    label: PULSE.I18N.lookup('label.filters.continent.americas')
  }, {
    value: 'ASIA',
    label: PULSE.I18N.lookup('label.filters.continent.asia')
  }, {
    value: 'EUROPE',
    label: PULSE.I18N.lookup('label.filters.continent.europe')
  }, {
    value: 'OCEANIA',
    label: PULSE.I18N.lookup('label.filters.continent.oceania')
  }];

  /**
   * Filter - Fed Region (Continent)
   * @extends app.Filter
   */
  app.FilterFedRegionWidget = class FilterFedRegionWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS[0].value;
      super('region', {
        defaultValue: defaultValue
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-fed-region',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.fedRegion'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      return this.listbox.setSelectByValue(targetValue);
    }
  };
})(PULSE.app);
"use strict";

(function (app, common, core) {
  'use strict';

  const {
    CLASSES
  } = common.CONSTANTS;
  const ANIMATION_DELAY = 500;

  /**
   * Filters Widget
   *
   * Wraps the any filters that are setup and handles their initialisation.
   * Along with URL updates, reset button logic and the filter modal.
   */
  app.FiltersWidget = class FiltersWidget {
    /**
     * Constructor
     *
     * @param { HTMLElement } container - container Element that widget is instantiated on
     */
    constructor(container) {
      this.container = container;
      this.filters = [].slice.call(container.querySelectorAll('[data-filter]'));
      this.activeFilterCountEl = container.querySelector('.js-active-filter-count');
      this.setupModalListeners();
      common.dependency.loaded('redux').then(this.hookupStore.bind(this));
      this.advancedFilterButton = container.querySelector('.js-filter-advanced-button');
      this.advancedFilters = container.querySelector('.js-filter-advanced');
      if (this.advancedFilterButton && this.advancedFilters) {
        this.setupAdvancedListeners();
      }
    }

    /**
     * Setup Modal Listeners
     *
     * Finds all the UI elements and attachs the relevant listeners for the
     * functionality of the filter modal.
     */
    setupModalListeners() {
      const filterBar = this.container.querySelector('.js-filter-bar');
      const openButton = this.container.querySelector('.js-open-modal');
      const closeButtons = this.container.querySelectorAll('.js-close-modal');
      common.closeOnOutsideClick.addElement(filterBar, () => {
        this.closeModal();
      }, this.container);
      if (openButton) {
        common.addAriaClickListener(openButton, this.openModal.bind(this));
      }
      if (closeButtons) {
        common.addMultiAriaClickListener(closeButtons, this.closeModal.bind(this));
      }
    }

    /**
     * Open Modal
     *
     * Adds the relevant classes to open the modal.
     */
    openModal() {
      core.style.addClass(this.container, CLASSES.IS_ACTIVE);
    }

    /**
     * Close Modal
     *
     * Adds the relevant classes to close the modal.
     */
    closeModal() {
      if (core.style.hasClass(this.container, CLASSES.IS_ACTIVE)) {
        core.style.removeClass(this.container, CLASSES.IS_ACTIVE);
      }
    }

    /**
     * Setup Advanced Listeners
     *
     * Sets up the listeners required for the advanced filters UI
     */
    setupAdvancedListeners() {
      common.addAriaClickListener(this.advancedFilterButton, this.toggleAdvanedFilters.bind(this));
    }

    /**
     * Toggle Advanced Filters
     *
     * Open and close the advanced filters window by toggling classes
     */
    toggleAdvanedFilters() {
      if (this.animationTimer) {
        clearTimeout(this.animationTimer);
      }
      if (core.style.hasClass(this.advancedFilters, CLASSES.IS_ACTIVE)) {
        this.advancedFilters.style.maxHeight = '';
        core.style.removeClass(this.advancedFilters, CLASSES.IS_OPEN);
      } else {
        this.advancedFilters.style.maxHeight = `${this.advancedFilters.scrollHeight}px`;
        this.animationTimer = setTimeout(() => core.style.addClass(this.advancedFilters, CLASSES.IS_OPEN), ANIMATION_DELAY);
      }
      core.style.toggleClass(this.advancedFilterButton, CLASSES.IS_ACTIVE);
      core.style.toggleClass(this.advancedFilters, CLASSES.IS_ACTIVE);
    }

    /**
     * Hookup store
     *
     * Fires once the redux store is loaded. Counts up the number of filters
     * and sends it to the store so we know when everything is setup and
     * ready to init. Also initialises each filter class and set's up
     * various watches on the redux store.
     */
    hookupStore() {
      const {
        watch,
        slices,
        store
      } = PULSE.app.redux;

      // Add the total count of filters to the store
      store.dispatch(slices.filters.actions.total(this.filters.length));

      // Initialise each filter widget
      for (var i = 0; i < this.filters.length; i++) {
        const filter = this.filters[i];
        const FilterConstructor = app[app.widgetInitialiser.getConstructorName(filter.dataset.filter)];
        new FilterConstructor(filter);
        filter.setAttribute('data-initialised', true);
      }

      // Setup watch to update the URL when filters change
      watch(slices.filters.paths.values.all, filtersParams => {
        const urlParams = common.url.paramsToObject(new URLSearchParams(location.search));
        const filtersAndParams = {
          // ensure non-filter query params are pesisted
          ...urlParams,
          ...filtersParams
        };
        if (!_.isEmpty(filtersParams)) {
          history.replaceState({}, {}, `${window.location.href.split('?')[0]}?${core.url.buildQueryString(filtersAndParams)}`);
        }
      }, true);

      // Hookup reset buttons
      const resetButtons = this.container.querySelectorAll('.js-filter-reset');
      common.addMultiAriaClickListener(resetButtons, this.resetFilters.bind(this));

      // Setup watch to update the active Filter count
      if (this.activeFilterCountEl) {
        watch(slices.filters.paths.activeCount, count => {
          if (count) {
            this.activeFilterCountEl.innerHTML = count;
            core.style.removeClass(this.activeFilterCountEl, CLASSES.U_HIDE);
          } else {
            core.style.addClass(this.activeFilterCountEl, CLASSES.U_HIDE);
          }
        }, true);
      }

      // Query for confirm buttons and if found enable confirm mode
      const confirmButtons = [].slice.call(this.container.querySelectorAll('.js-filter-confirm'));
      if (Array.isArray(confirmButtons) && confirmButtons.length) {
        // Set confirm mode
        store.dispatch(slices.filters.actions.enableConfirmMode());
        common.addMultiAriaClickListener(confirmButtons, this.confirmFilters.bind(this));

        // Setup watch to hide/show the button if there are filters staged
        watch(slices.filters.paths.stage.all, stage => {
          if (_.isEmpty(stage)) {
            confirmButtons.forEach(button => core.style.removeClass(button, CLASSES.IS_ACTIVE));
          } else {
            confirmButtons.forEach(button => core.style.addClass(button, CLASSES.IS_ACTIVE));
          }
        }, true);
      }
    }

    /**
     * Reset Filters
     *
     * Fires when any reset button is clicked. Dispatches the reset thunk.
     */
    resetFilters() {
      const {
        store,
        slices
      } = PULSE.app.redux;
      store.dispatch(slices.filters.thunks.reset());
    }

    /**
     * Confirm Filters
     *
     * Commits whatever is on the stage when the search/confirm button is
     * clicked.
     *
     * @param {Event} event - Event object
     */
    confirmFilters(event) {
      if (event) {
        event.preventDefault();
      }
      const {
        store,
        slices
      } = PULSE.app.redux;
      store.dispatch(slices.filters.actions.commit());
    }
  };
  app.widgetInitialiser.addMultipleWidgetsByName('filters');
})(PULSE.app, PULSE.app.common, PULSE.core);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - The options that power the listbox
   */
  const OPTIONS = [{
    value: 'M',
    label: `${PULSE.I18N.lookup('label.filters.gender.M')} - Elite`
  }, {
    value: 'F',
    label: `${PULSE.I18N.lookup('label.filters.gender.F')} - Elite`
  }, {
    value: 'B',
    label: PULSE.I18N.lookup('label.filters.gender.B')
  }, {
    value: 'G',
    label: PULSE.I18N.lookup('label.filters.gender.G')
  }];

  /**
   * Filter - Gender
   * @extends app.Filter
   */
  app.FilterGenderAltYouthWidget = class FilterGenderAltYouthWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      let options = OPTIONS;
      const attributeOptions = container.getAttribute('data-options');
      if (attributeOptions) {
        const attributeOptionsArr = attributeOptions.split(',');
        options = attributeOptionsArr.map(option => OPTIONS.find(item => item.value === option));
      }
      const defaultValue = options[0].value;
      const initialValue = container.getAttribute('data-initial-value');
      super('gender', {
        defaultValue: defaultValue,
        initialValue: initialValue ? initialValue : defaultValue
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-gender',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.gender'),
        options: options
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - The options that power the listbox
   */
  const OPTIONS = [{
    value: 'M',
    label: PULSE.I18N.lookup('label.filters.gender.M')
  }, {
    value: 'F',
    label: PULSE.I18N.lookup('label.filters.gender.F')
  }];

  /**
   * Filter - Gender
   * @extends app.Filter
   */
  app.FilterGenderAltWidget = class FilterGenderAltWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      let options = OPTIONS;
      const attributeOptions = container.getAttribute('data-options');
      if (attributeOptions) {
        const attributeOptionsArr = attributeOptions.split(',');
        options = attributeOptionsArr.map(option => OPTIONS.find(item => item.value === option));
      }
      const defaultValue = options[0].value;
      const initialValue = container.getAttribute('data-initial-value');
      super('gender', {
        defaultValue: defaultValue,
        initialValue: initialValue ? initialValue : defaultValue
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-gender',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.gender'),
        options: options
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - The options that power the listbox
   */
  const OPTIONS = [{
    value: 'M',
    label: PULSE.I18N.lookup('label.filters.gender.M')
  }, {
    value: 'F',
    label: PULSE.I18N.lookup('label.filters.gender.F')
  }, {
    value: 'X',
    label: PULSE.I18N.lookup('label.filters.gender.X')
  }];

  /**
   * Filter - Gender
   * @extends app.Filter
   */
  app.FilterGenderWidget = class FilterGenderWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      let options = OPTIONS;
      const attributeOptions = container.getAttribute('data-options');
      if (attributeOptions) {
        const attributeOptionsArr = attributeOptions.split(',');
        options = attributeOptionsArr.map(option => OPTIONS.find(item => item.value === option));
      }
      const defaultValue = options[0].value;
      const initialValue = container.getAttribute('data-initial-value');
      super('gender', {
        defaultValue: defaultValue,
        initialValue: initialValue ? initialValue : defaultValue
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-gender',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.gender'),
        options: options
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - The options that power the listbox
   */
  const OPTIONS = [{
    value: 'FINA',
    label: PULSE.I18N.lookup('label.filters.comptype.fina')
  }, {
    value: 'OTHER',
    label: PULSE.I18N.lookup('label.filters.comptype.nonFina')
  }];

  /**
   * Filter - Group (Competition Type)
   * @extends app.Filter
   */
  app.FilterGroupWidget = class FilterGroupWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS[0].value;
      const initialValue = container.getAttribute('data-initial-value');
      super('group', {
        defaultValue: defaultValue,
        initialValue: initialValue ? initialValue : defaultValue
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-comp-type',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.group'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }
  };
})(PULSE.app);
"use strict";

(function (app, CONSTANTS, core) {
  'use strict';

  const {
    CLASSES
  } = CONSTANTS;

  /**
   * Filter - Mobile Athlete Search
   * @extends app.Filter
   */
  app.FilterMobileAthleteSearchWidget = class FilterMobileAthleteSearchWidget extends app.Filter {
    /*eslint-disable-line id-length */
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('name', {
        defaultValue: ''
      });
      const underNavContainer = document.querySelector('.js-under-nav-marker');
      const formEle = container.querySelector('.js-mobile-search-form');
      if (!underNavContainer || !formEle) {
        return;
      }

      // Sits outside of the moved form so just query 'container'
      this.openButton = container.querySelector('.js-mobile-search-open');

      // Grab the form and move it into the marker below the nav
      underNavContainer.appendChild(formEle);
      this.container = underNavContainer;
      this.input = this.container.querySelector('.js-search-input');
      this.closeButton = this.container.querySelector('.js-mobile-search-close');
      this.searchButton = this.container.querySelector('.js-filter-confirm');
      app.common.closeOnOutsideClick.addElement(this.input, () => {
        this.closeMobileSearch(null, false);
      }, container);
      if (!this.input) {
        return;
      }
      this.input.addEventListener('input', event => super.change(event.target.value));
      app.common.addAriaClickListener(this.openButton, this.openMobileSearch.bind(this));
      app.common.addAriaClickListener(this.closeButton, this.closeMobileSearch.bind(this));
      app.common.addAriaClickListener(this.searchButton, event => {
        this.closeMobileSearch(event, false);
        super.confirmFilters();
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - True as we can always update the value of the field
     */
    updateUI(value) {
      if (this.input.value !== value) {
        this.input.value = value;
      }
      return true;
    }

    /**
     * Open Mobile Search
     *
     * Add classes and focus the now visible search input.
     *
     * @param {Event} event - The event object
     */
    openMobileSearch(event) {
      if (event) {
        event.preventDefault();
      }
      core.style.addClass(this.container, CLASSES.IS_ACTIVE);
      this.input.focus();
    }

    /**
     * Close Mobile Search
     *
     * Remove class and optionally reset the name search value
     *
     * @param {Event} event - The event object
     * @param {Boolean} reset - Flag to trigger a reset of the search
     */
    closeMobileSearch(event) {
      let reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (event) {
        event.preventDefault();
      }
      core.style.removeClass(this.container, CLASSES.IS_ACTIVE);
      if (reset) {
        super.change('');
        super.confirmFilters();
      }
    }
  };
})(PULSE.app, PULSE.app.common.CONSTANTS, PULSE.core);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - The phase options for the listbox
   */
  const OPTIONS = [{
    value: 'All',
    label: PULSE.I18N.lookup('label.filters.phase.all')
  }, {
    value: 'Finals',
    label: PULSE.I18N.lookup('label.filters.phase.finals')
  }];

  /**
   * Filter - Phase
   * @extends app.Filter
   */
  app.FilterPhaseWidget = class FilterPhaseWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('phase', {
        defaultValue: OPTIONS[0].value
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-phase',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.phase'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - All pool size options
   */
  const OPTIONS = [{
    value: 'LCM',
    // 50m (Long course meters)
    label: PULSE.I18N.lookup('label.filters.pool.lcm')
  }, {
    value: 'SCM',
    // 25m (Short course meters)
    label: PULSE.I18N.lookup('label.filters.pool.scm')
  }];
  const OPTIONS_ONLY_SCM = [{
    value: 'SCM',
    label: PULSE.I18N.lookup('label.filters.pool.scm')
  }];
  const FIFTY_ONLY_SCM = ['FREESTYLE_RELAY', 'MEDLEY_RELAY'];
  const HUNDRED_ONLY_SCM = ['MEDLEY'];

  /**
   * Filter - Pool (Size)
   * @extends app.Filter
   */
  app.FilterPoolWidget = class FilterPoolWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS[0].value;
      const initialValue = container.getAttribute('data-initial-value');
      super('poolConfiguration', {
        defaultValue: defaultValue,
        initialValue: initialValue ? initialValue : defaultValue,
        dependency: ['distance', 'stroke']
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-pool',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.pool'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {String} dependencyValue - The staged value of our dependency
     * @param {Object} filterState - The current filterState
     * @param {String} dependencyKey - The key of our staged depdency
     */
    dependencyStaged(dependencyValue, filterState, dependencyKey) {
      /**
       * Always use the new incoming dependancyValue if it's the right key
       * or fetch the value from the 'stage' or lastly the 'values' in the
       * state, then use both to work out what todo
       */
      const distance = String(dependencyKey === 'distance' ? dependencyValue : filterState.stage.distance || filterState.values.distance);
      const stroke = String(dependencyKey === 'stroke' ? dependencyValue : filterState.stage.stroke || filterState.values.stroke);

      // If 50 or 100 distance & then one of the limited strokes, set to only SCM
      if (distance === '50' && FIFTY_ONLY_SCM.includes(stroke) || distance === '100' && HUNDRED_ONLY_SCM.includes(stroke)) {
        this.updateListboxOptions(OPTIONS_ONLY_SCM);
      } else {
        this.updateListboxOptions(OPTIONS);
      }
    }

    /**
     * Update Listbox Options
     *
     * Take a set of options, look to see if the current value of the filter
     * is in those options, if it is, then render the listbox and pick that
     * value. Otherwise, re-render the filter picking the first item as the
     * selected value and also fire a change call for the store.
     *
     * @param {Array} options - Options array of value/label objects
     */
    updateListboxOptions(options) {
      if (options.find(option => option.value === this.value) ? true : false) {
        this.listbox.render(options, this.value);
      } else {
        this.listbox.render(options);
        super.change(options[0].value);
      }
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - All dropdown options
   */
  const OPTIONS = [{
    value: 'ALL',
    label: PULSE.I18N.lookup('label.filters.all')
  }, {
    value: 'bf2bd696-5a56-4331-b50c-e526c0686254',
    label: PULSE.I18N.lookup('label.filters.programmeCategory.clinicsForCoaches')
  }, {
    value: '217f9410-b304-41e0-b471-524e8e334d83',
    label: PULSE.I18N.lookup('label.filters.programmeCategory.clinicsForOfficials')
  }, {
    value: '77c6b905-264c-424b-b8a9-3e4bd568ee79',
    label: PULSE.I18N.lookup('label.filters.programmeCategory.FINACoachesCertification')
  }, {
    value: '3a9e7426-e715-4d8f-8173-56bcfb18e467',
    label: PULSE.I18N.lookup('label.filters.programmeCategory.FINASchoolsForOfficials')
  }, {
    value: '65ad91ca-8e98-4e86-a4da-5bb444fde20e',
    label: PULSE.I18N.lookup('label.filters.programmeCategory.aquaticManagersProgramme')
  }];

  /**
   * Filter - Development (Calendar) Programme Category
   * @extends app.Filter
   */
  app.FilterProgrammeCatWidget = class FilterProgrammeCatWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('programCat', {
        defaultValue: OPTIONS[0].value
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-programme-cat',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.programmeCategory'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      return this.listbox.setSelectByValue(targetValue);
    }
  };
})(PULSE.app, PULSE.core);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - The options that power the listbox
   */
  const OPTIONS = [{
    value: 'all',
    label: PULSE.I18N.lookup('label.filters.qualificationStandard.all')
  }, {
    value: '2',
    label: PULSE.I18N.lookup('label.filters.qualificationStandard.A')
  }, {
    value: '3',
    label: PULSE.I18N.lookup('label.filters.qualificationStandard.B')
  }, {
    value: '4',
    label: PULSE.I18N.lookup('label.filters.qualificationStandard.U')
  }];

  /**
   * Filter - Qualification Standard
   * @extends app.Filter
   */
  app.FilterQualificationStandardWidget = class FilterQualificationStandardWidget extends app.Filter {
    /*eslint-disable-line id-length */
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS[0].value;
      super('standard', {
        defaultValue: defaultValue
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-qualification-standard',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.qualificationStandard'),
        options: OPTIONS,
        cssClass: 'listbox--wide'
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Object} ALL_OPTIONS - All stroke options, stored by value key.
   * These are used to build options arrays at the bottom of the file. If you
   * update any keys, please update them in the various stroke and gender
   * groups at the bottom of the file.
   */
  const ALL_OPTIONS = {
    FREESTYLE: {
      value: 'FREESTYLE',
      label: PULSE.I18N.lookup('label.filters.stroke.FREESTYLE')
    },
    BACKSTROKE: {
      value: 'BACKSTROKE',
      label: PULSE.I18N.lookup('label.filters.stroke.BACKSTROKE')
    },
    BREASTSTROKE: {
      value: 'BREASTSTROKE',
      label: PULSE.I18N.lookup('label.filters.stroke.BREASTSTROKE')
    },
    BUTTERFLY: {
      value: 'BUTTERFLY',
      label: PULSE.I18N.lookup('label.filters.stroke.BUTTERFLY')
    },
    MEDLEY: {
      value: 'MEDLEY',
      label: PULSE.I18N.lookup('label.filters.stroke.MEDLEY')
    }
  };

  /**
   * Filter - Qualifying Stroke
   * @extends app.Filter
   */
  app.FilterQualifyingStrokeWidget = class FilterQualifyingStrokeWidget extends app.Filter {
    /* eslint-disable-line id-length */
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = MW_OPTIONS['50'][0].value;
      const initialValue = container.getAttribute('data-initial-value');
      super('stroke', {
        defaultValue: defaultValue,
        initialValue: initialValue ? initialValue : defaultValue,
        dependency: 'distance'
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-stroke',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.stroke'),
        options: MW_OPTIONS['50']
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {Number} distance - The staged value of our dependency
     */
    dependencyStaged(distance) {
      const optionsList = MW_OPTIONS[String(distance)];
      this.updateListboxOptions(optionsList);
    }

    /**
     * Update Listbox Options
     *
     * Take a set of options, look to see if the current value of the filter
     * is in those options, if it is, then render the listbox and pick that
     * value. Otherwise, re-render the filter picking the first item as the
     * selected value and also fire a change call for the store.
     *
     * @param {Array} options - Options array of value/label objects
     */
    updateListboxOptions(options) {
      if (options.find(option => option.value === this.value) ? true : false) {
        this.listbox.render(options, this.value);
      } else {
        this.listbox.render(options);
        super.change(options[0].value);
      }
    }
  };

  /**
   * Get Options Array
   *
   * Maps an array of values into an array of both the values and the labels
   * from the ALL_OPTIONS array.
   *
   * @param {Array} values - An array of values that are found in ALL_OPTIONS
   * @returns {Array} An array of full value and label objects for each option
   */
  const _getOptionsArray = values => values.map(value => ALL_OPTIONS[value]);

  /**
   * @const {Object} MF_OPTIONS - Strokes available at each distance for both Men and Women
   */
  const MW_OPTIONS = {
    50: _getOptionsArray(['FREESTYLE', 'BACKSTROKE', 'BREASTSTROKE', 'BUTTERFLY']),
    100: _getOptionsArray(['FREESTYLE', 'BACKSTROKE', 'BREASTSTROKE', 'BUTTERFLY', 'MEDLEY']),
    200: _getOptionsArray(['FREESTYLE', 'BACKSTROKE', 'BREASTSTROKE', 'BUTTERFLY', 'MEDLEY']),
    400: _getOptionsArray(['FREESTYLE', 'MEDLEY']),
    800: _getOptionsArray(['FREESTYLE']),
    1500: _getOptionsArray(['FREESTYLE'])
  };
})(PULSE.app);
"use strict";

(function (app, common) {
  'use strict';

  const DEFAULT_OLDEST_YEAR = 2000;

  /**
   * Filter - Competition Year
   * @extends app.Filter
   */
  app.FilterRankingsYearWidget = class FilterRankingsYearWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const OLDEST_YEAR = container.getAttribute('data-oldest-year') || DEFAULT_OLDEST_YEAR;
      const OPTIONS = common.date.getArrayOfYears(OLDEST_YEAR);
      OPTIONS.unshift({
        value: 'all',
        label: PULSE.I18N.lookup('label.filters.rankingsYear.all')
      });
      super('year', {
        defaultValue: OPTIONS[0].value
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-rankings-year',
        selectCallback: value => {
          // Convert year to a number, if we can!
          const numberValue = Number(value);
          if (isNaN(numberValue)) {
            super.change(value);
          } else {
            super.change(numberValue);
          }
        },
        label: PULSE.I18N.lookup('label.filters.rankingsYear'),
        options: OPTIONS,
        cssClass: 'listbox--wide'
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI() {
      let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      const targetValue = value || '';
      return this.listbox.setSelectByValue(targetValue);
    }
  };
})(PULSE.app, PULSE.app.common);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - The options that power the listbox
   */
  const OPTIONS = [{
    value: 'WR',
    label: PULSE.I18N.lookup('label.filters.recordCode.WR')
  }, {
    value: 'OR',
    label: PULSE.I18N.lookup('label.filters.recordCode.OR')
  }, {
    value: 'WJ',
    label: PULSE.I18N.lookup('label.filters.recordCode.WJ')
  }, {
    value: 'MR',
    label: PULSE.I18N.lookup('label.filters.recordCode.MR')
  }, {
    value: 'CR',
    label: PULSE.I18N.lookup('label.filters.recordCode.CR')
  }, {
    value: 'NR',
    label: PULSE.I18N.lookup('label.filters.recordCode.NR')
  }];

  /**
   * Filter - Record Code (type)
   * @extends app.Filter
   */
  app.FilterRecordCodeWidget = class FilterRecordCodeWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS[0].value;
      const initialValue = container.getAttribute('data-initial-value');
      super('recordCode', {
        defaultValue: defaultValue,
        initialValue: initialValue ? initialValue : defaultValue
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-record-code',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.recordCode'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }
  };
})(PULSE.app);
"use strict";

(function (app, core) {
  'use strict';

  const {
    CLASSES
  } = app.common.CONSTANTS;

  /**
   * Filter - Country Id
   * @extends app.Filter
   */
  app.FilterRecordCountryIdWidget = class FilterRecordCountryIdWidget extends app.Filter {
    /*eslint-disable-line id-length */
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('countryId', {
        defaultValue: '',
        dependency: 'recordCode'
      });
      this.value = '';
      this.filterItemEle = container.parentElement;

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-record-country',
        selectCallback: value => {
          this.value = value;
          super.change(value);
        },
        label: PULSE.I18N.lookup('label.filters.recordCountry'),
        options: []
      });
      this.fetchCountries();
    }

    /**
     * Fetch Countries
     *
     * Fire off request to the countries endpoint to get back a list of
     * countries
     */
    fetchCountries() {
      const url = app.common.endpoints.fina.countries.all();
      core.data.request(url, 'GET', this.handleCountriesResponse.bind(this), [app.account]);
    }

    /**
     * Handle Countries Response
     *
     * Callback function for when the countries api returns a list of
     * countries. Checks the data then maps them to an options array and
     * renders them into the listbox.
     *
     * @param {Array} data - Response from countries api
     */
    handleCountriesResponse(data) {
      if (!data || !data.length) {
        console.warn('[countryId Filter] There was an error fetching the countries list.');
        return;
      }

      // Model the countries in the countries api response
      const modelledCountries = data.map(country => ({
        value: country.Id,
        label: `${app.templating.render({
          cssClass: 'listbox__flag',
          countryCode: country.Code
        }, 'filters.lazy-flag')} ${country.Code} - ${country.Name}`,
        textLabel: `${country.Code} - ${country.Name}`,
        code: country.Code,
        continent: country.RegionName
      }));

      /* Sort the coutries by Country Code and add the them to the window
       * so we can use the country names from the response to populate the
       * title in swimming-rankings.js */
      window.COUNTRIES = modelledCountries.sort((a, b) => a.code.localeCompare(b.code));
      app.common.fireEvent(app.common.CONSTANTS.EVENTS.COUNTRIES.LOADED);
      this.listbox.render(window.COUNTRIES, this.value, this.renderFlags.bind(this));
    }

    /**
     * Render Flags
     *
     * Callback fired once the listbox has rendered, this kicks of the lazy
     * loading of flags.
     *
     * @param {HTMLElement} listbox - The listbox node
     */
    renderFlags(listbox) {
      new app.LazyFlag(listbox);
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      this.value = value;
      if (targetValue) {
        core.style.removeClass(this.filterItemEle, CLASSES.U_HIDE);
      }
      return this.listbox.setSelectByValue(targetValue);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {*} recordCode - The staged value of our dependency
     */
    dependencyStaged(recordCode) {
      if (recordCode === 'NR') {
        const newValue = this.value ? this.value : window.COUNTRIES ? window.COUNTRIES[0].value : '';
        this.listbox.setSelectByValue(newValue);
        super.change(newValue);
        core.style.removeClass(this.filterItemEle, CLASSES.U_HIDE);
      } else {
        super.change('');
        core.style.addClass(this.filterItemEle, CLASSES.U_HIDE);
      }
    }
  };
})(PULSE.app, PULSE.core);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - The options that power the listbox
   */
  const OPTIONS = {
    M: {
      value: 'M',
      label: PULSE.I18N.lookup('label.filters.gender.M')
    },
    F: {
      value: 'F',
      label: PULSE.I18N.lookup('label.filters.gender.F')
    },
    X: {
      value: 'X',
      label: PULSE.I18N.lookup('label.filters.gender.X')
    }
  };
  const OPTIONS_ALL = [OPTIONS.M, OPTIONS.F, OPTIONS.X];
  const OPTIONS_MF = [OPTIONS.M, OPTIONS.F];

  /**
   * Filter - Record Gender
   * @extends app.Filter
   */
  app.FilterRecordGenderWidget = class FilterRecordGenderWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS_ALL[0].value;
      super('gender', {
        defaultValue: defaultValue,
        dependency: 'recordCode'
      });
      this.optionsSet === 'ALL';

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-gender',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.gender'),
        options: OPTIONS_ALL
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {String} dependencyValue - The staged value of our dependency
     */
    dependencyStaged(dependencyValue) {
      // If olympic records, only have MF options
      if (dependencyValue === 'OR' && (!this.optionsSet || this.optionsSet === 'ALL')) {
        this.optionsSet = 'MF';
        this.updateListboxOptions(OPTIONS_MF);
        // else have all options, if not already available
      } else if (this.optionsSet !== 'ALL') {
        this.optionsSet = 'ALL';
        this.updateListboxOptions(OPTIONS_ALL);
      }
    }

    /**
     * Update Listbox Options
     *
     * Take a set of options, look to see if the current value of the filter
     * is in those options, if it is, then render the listbox and pick that
     * value. Otherwise, re-render the filter picking the first item as the
     * selected value and also fire a change call for the store.
     *
     * @param {Array} options - Options array of value/label objects
     */
    updateListboxOptions(options) {
      if (options.find(option => option.value === this.value) ? true : false) {
        this.listbox.render(options, this.value);
      } else {
        this.listbox.render(options);
        super.change(options[0].value);
      }
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  const {
    COMP_TYPES
  } = app.common.CONSTANTS;

  /**
   * @const {Object} OPTIONS - All pool size options objects, with values and labels
   */
  const OPTIONS = {
    LCM: {
      value: 'LCM',
      label: PULSE.I18N.lookup('label.filters.pool.lcm')
    },
    SCM: {
      value: 'SCM',
      label: PULSE.I18N.lookup('label.filters.pool.scm')
    }
  };

  /**
   * @const {Array} OPTIONS_ALL - All pool size options in an array
   */
  const OPTIONS_ALL = [OPTIONS.LCM, OPTIONS.SCM];

  /**
   * @const {Array} OPTIONS_ONLY_LCM - Only LCM pool size option in an array
   */
  const OPTIONS_ONLY_LCM = [OPTIONS.LCM];

  /**
   * @const {Array} OPTIONS_ONLY_SCM - Only SCM pool size option in an array
   */
  const OPTIONS_ONLY_SCM = [OPTIONS.SCM];

  /**
   * @const {Array} OPTIONS_BY_EVENT_ID - Options avaiable for each event id
   */
  const OPTIONS_BY_EVENT_ID = {
    // Champ Swim Series
    [COMP_TYPES.CHAMPIONS_SWIM_SERIES]: OPTIONS_ONLY_LCM,
    // Swimming World Cup
    [COMP_TYPES.SWIMMING_WORLD_CUP]: OPTIONS_ALL,
    // World Championships
    [COMP_TYPES.WORLD_CHAMPIONSHIPS]: OPTIONS_ONLY_LCM,
    // World Swimming Championships 25m
    [COMP_TYPES.WORLD_SWIMMING_CHAMPIONSHIPS_25M]: OPTIONS_ONLY_SCM,
    // World Junior Swimming Championships
    [COMP_TYPES.WORLD_JUNIOR_SWIMMING_CHAMPIONSHIPS]: OPTIONS_ONLY_LCM
  };

  /**
   * Filter - Record Pool (Size)
   * @extends app.Filter
   */
  app.FilterRecordPoolWidget = class FilterRecordPoolWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS_ALL[0].value;
      super('pool', {
        defaultValue: defaultValue,
        dependency: ['recordCode', 'eventTypeId']
      });
      this.optionsSet = 'ALL';

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-pool',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.pool'),
        options: OPTIONS_ALL
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {String} dependencyValue - The staged value of our dependency
     * @param {Object} filterState - The current filterState
     * @param {String} dependencyKey - The key of our staged depdency
     */
    dependencyStaged(dependencyValue, filterState, dependencyKey) {
      // If the event type has changed, check for limits
      if (dependencyKey === 'eventTypeId' && dependencyValue) {
        this.updateListboxOptions(OPTIONS_BY_EVENT_ID[dependencyValue]);
        // or if Olympic records, set to only LCM (50m)
      } else if (dependencyKey === 'recordCode' && dependencyValue === 'OR') {
        this.updateListboxOptions(OPTIONS_ONLY_LCM);
        // or the recordCode is no longer MR reset it
      } else if (dependencyKey === 'recordCode' && dependencyValue !== 'MR') {
        this.optionsSet = 'ALL';
        this.updateListboxOptions(OPTIONS_ALL);
      }
    }

    /**
     * Update Listbox Options
     *
     * Take a set of options, look to see if the current value of the filter
     * is in those options, if it is, then render the listbox and pick that
     * value. Otherwise, re-render the filter picking the first item as the
     * selected value and also fire a change call for the store.
     *
     * @param {Array} options - Options array of value/label objects
     */
    updateListboxOptions(options) {
      if (options.find(option => option.value === this.value) ? true : false) {
        this.listbox.render(options, this.value);
      } else {
        this.listbox.render(options);
        super.change(options[0].value);
      }
    }
  };
})(PULSE.app);
"use strict";

(function (app, core) {
  'use strict';

  const {
    CLASSES
  } = app.common.CONSTANTS;

  /**
   * @const {Array} OPTIONS - All pool size options
   */
  const OPTIONS = [{
    value: 'AFRICA',
    label: PULSE.I18N.lookup('label.filters.continent.africa')
  }, {
    value: 'AMERICAS',
    label: PULSE.I18N.lookup('label.filters.continent.americas')
  }, {
    value: 'ASIA',
    label: PULSE.I18N.lookup('label.filters.continent.asia')
  }, {
    value: 'EUROPE',
    label: PULSE.I18N.lookup('label.filters.continent.europe')
  }, {
    value: 'OCEANIA',
    label: PULSE.I18N.lookup('label.filters.continent.oceania')
  }];

  /**
   * Filter - Region (Continent) for Records
   * @extends app.Filter
   */
  app.FilterRecordRegionWidget = class FilterRecordRegionWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('region', {
        defaultValue: '',
        dependency: 'recordCode'
      });
      this.filterItemEle = container.parentElement;

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-record-continent',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.recordContinent'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      if (targetValue) {
        core.style.removeClass(this.filterItemEle, CLASSES.U_HIDE);
      }
      return this.listbox.setSelectByValue(targetValue);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {*} recordCode - The staged value of our dependency
     */
    dependencyStaged(recordCode) {
      if (recordCode === 'CR') {
        const newValue = this.value || OPTIONS[0].value;
        this.listbox.setSelectByValue(newValue);
        super.change(newValue);
        core.style.removeClass(this.filterItemEle, CLASSES.U_HIDE);
      } else {
        super.change('');
        core.style.addClass(this.filterItemEle, CLASSES.U_HIDE);
      }
    }
  };
})(PULSE.app, PULSE.core);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - All pool size options
   */
  const OPTIONS = [{
    value: 'all',
    label: PULSE.I18N.lookup('label.filters.continent.all')
  }, {
    value: 'AFRICA',
    label: PULSE.I18N.lookup('label.filters.continent.africa')
  }, {
    value: 'AMERICAS',
    label: PULSE.I18N.lookup('label.filters.continent.americas')
  }, {
    value: 'ASIA',
    label: PULSE.I18N.lookup('label.filters.continent.asia')
  }, {
    value: 'EUROPE',
    label: PULSE.I18N.lookup('label.filters.continent.europe')
  }, {
    value: 'OCEANIA',
    label: PULSE.I18N.lookup('label.filters.continent.oceania')
  }];

  /**
   * Filter - Region Id (Continent)
   * @extends app.Filter
   */
  app.FilterRegionIdWidget = class FilterRegionIdWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS[0].value;
      const initialValue = container.getAttribute('data-initial-value');
      super('regionId', {
        defaultValue: defaultValue,
        initialValue: initialValue ? initialValue : defaultValue
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-region-id',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.continent'),
        options: OPTIONS,
        cssClass: 'listbox--wide'
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      const targetValue = value || '';
      return this.listbox.setSelectByValue(targetValue);
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * Filter - Series Ranking Discipline
   * @extends app.Filter
   */
  app.FilterSeriesRankingDisciplineWidget = class FilterSeriesRankingDisciplineWidget extends app.Filter {
    /*eslint-disable-line id-length */
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const options = window.seriesRankingDisciplines;
      const defaultValue = options[0].value;
      super('discipline', {
        defaultValue
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-series-discipline',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.discipline'),
        options: options
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * Filter - Series Ranking Scoring
   * @extends app.Filter
   */
  app.FilterSeriesRankingScoringWidget = class FilterSeriesRankingScoringWidget extends app.Filter {
    /*eslint-disable-line id-length */
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const options = window.seriesRankingScorings;
      const defaultValue = options[0].value;
      super('scoringId', {
        defaultValue,
        dependency: 'discipline'
      });
      this.allOptions = options;

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-series-ranking',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.seriesRanking'),
        options: options
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {*} value - The staged value of our dependency
     */
    dependencyStaged(value) {
      let options;
      if (value) {
        options = this.allOptions.filter(option => option.discipline === value);
      } else {
        options = this.allOptions;
      }
      this.updateListboxOptions(options);
    }

    /**
     * Update Listbox Options
     *
     * Take a set of options, look to see if the current value of the filter
     * is in those options, if it is, then render the listbox and pick that
     * value. Otherwise, re-render the filter picking the first item as the
     * selected value and also fire a change call for the store.
     *
     * @param {Array} options - Options array of value/label objects
     */
    updateListboxOptions(options) {
      if (options.find(option => option.value === this.value) ? true : false) {
        this.listbox.render(options, this.value);
      } else {
        this.listbox.render(options);
        super.change(options[0].value);
      }
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  const API_DATE_FORMAT = 'MM/DD/YYYY';
  const DISPLAY_DATE_FORMAT = 'DD/MM/YYYY';
  const INPUT_DATE_FORMAT = 'YYYY-MM-DD';

  /**
   * Filter - Start Date
   * @extends app.Filter
   */
  app.FilterStartDateWidget = class FilterStartDateWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      super('startDate', {
        defaultValue: '',
        dependency: ['year', 'endDate']
      });
      const datePickerButton = container.querySelector('.js-date-picker');
      this.datePickerValue = container.querySelector('.js-date-picker-value');
      this.datePickerInput = container.querySelector('.js-date-picker-input');
      this.datePicker = datepicker(datePickerButton, {
        onSelect: (instance, date) => {
          this.setDate(date);
          const dateDayjs = dayjs(date);
          this.datePickerValue.innerHTML = dateDayjs.format(DISPLAY_DATE_FORMAT);
        },
        position: 'br'
      });
      this.datePickerInput.addEventListener('blur', event => {
        const valueDayjs = dayjs(event.target.value);
        this.datePicker.setDate(valueDayjs.toDate(), true);
        super.change(valueDayjs.format(API_DATE_FORMAT));
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      if (value) {
        this.datePicker.setDate(new Date(value), true);
        this.datePickerValue.innerHTML = dayjs(value).format(DISPLAY_DATE_FORMAT);
        this.datePickerInput.value = dayjs(value).format(INPUT_DATE_FORMAT);
      } else {
        this.datePicker.setDate();
        this.datePickerValue.innerHTML = '';
        this.datePickerInput.value = '';
      }
      return true;
    }

    /**
     * Set Min From Year
     *
     * Given a year, update both the datepicker and date field to have min
     * limits so the user can't pick dates outside the year they've picked.
     *
     * @param {Number} year - The year to limit by
     */
    setMinFromYear(year) {
      if (year) {
        const dateDayjs = dayjs(new Date(year, 0, 1));
        this.datePickerInput.min = dateDayjs.format(INPUT_DATE_FORMAT);
        /** See if mins and maxes can be set around current date, if not
         * catch the error and unset the date and try again */
        try {
          this.datePicker.setMin(dateDayjs.toDate());
        } catch (error) {
          this.updateUI();
          this.datePicker.setMin(dateDayjs.toDate());
        }
        this.datePicker.navigate(dateDayjs.toDate());
      } else {
        this.datePicker.setMin();
        this.datePickerInput.min = '';
      }
    }

    /**
     * Set Max From Date
     *
     * Given a date, update both the datepicker and date field to have max
     * limits so the user can't pick dates outside the year they've picked.
     *
     * @param {String|Date} date - The year to limit by
     */
    setMaxFromDate(date) {
      if (date) {
        const dateDayjs = dayjs(date);
        this.datePickerInput.max = dateDayjs.format(INPUT_DATE_FORMAT);
        /** See if mins and maxes can be set around current date, if not
         * catch the error and unset the date and try again */
        try {
          this.datePicker.setMax(dateDayjs.toDate());
        } catch (error) {
          this.updateUI();
          this.datePicker.setMax(dateDayjs.toDate());
        }
      } else {
        this.datePicker.setMax();
        this.datePickerInput.max = '';
      }
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {String} dependencyValue - The staged value of our dependency
     * @param {Object} filterState - The current filterState
     * @param {String} dependencyKey - The key of our staged depdency
     */
    dependencyStaged(dependencyValue, filterState, dependencyKey) {
      this.setMinFromYear();
      this.setMaxFromDate();
      if (dependencyKey === 'year' && dependencyValue && dependencyValue !== 'all') {
        this.setMinFromYear(dependencyValue);
        this.setMaxFromDate(new Date(dependencyValue, 11, 31)); //eslint-disable-line no-magic-numbers

        this.setDate(this.datePicker.dateSelected);
      } else if (dependencyKey === 'endDate' && dependencyValue) {
        const currentYear = filterState.stage.year || filterState.values.year;
        if (currentYear && currentYear !== 'all') {
          this.setMinFromYear(currentYear);
        }
        this.setMaxFromDate(dependencyValue);
        this.setDate(this.datePicker.dateSelected);
      }
    }

    /**
     * Set Date
     *
     * Checks to see if a date is present and sets it. If the date is false
     * then instead we set an empty string in the store.
     *
     * @param {Date} date - A JS Date instance
     */
    setDate(date) {
      if (date) {
        const dateDayjs = dayjs(date);
        super.change(dateDayjs.format(API_DATE_FORMAT));
        return;
      }
      super.change('');
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Object} ALL_OPTIONS - All stroke options, stored by value key.
   * These are used to build options arrays at the bottom of the file. If you
   * update any keys, please update them in the various stroke and gender
   * groups at the bottom of the file.
   */
  const ALL_OPTIONS = {
    FREESTYLE: {
      value: 'FREESTYLE',
      label: PULSE.I18N.lookup('label.filters.stroke.FREESTYLE')
    },
    BACKSTROKE: {
      value: 'BACKSTROKE',
      label: PULSE.I18N.lookup('label.filters.stroke.BACKSTROKE')
    },
    BREASTSTROKE: {
      value: 'BREASTSTROKE',
      label: PULSE.I18N.lookup('label.filters.stroke.BREASTSTROKE')
    },
    BUTTERFLY: {
      value: 'BUTTERFLY',
      label: PULSE.I18N.lookup('label.filters.stroke.BUTTERFLY')
    },
    MEDLEY: {
      value: 'MEDLEY',
      label: PULSE.I18N.lookup('label.filters.stroke.MEDLEY')
    },
    FREESTYLE_RELAY: {
      value: 'FREESTYLE_RELAY',
      label: PULSE.I18N.lookup('label.filters.stroke.FREESTYLE_RELAY')
    },
    MEDLEY_RELAY: {
      value: 'MEDLEY_RELAY',
      label: PULSE.I18N.lookup('label.filters.stroke.MEDLEY_RELAY')
    }
  };

  /**
   * Filter - Stroke
   * @extends app.Filter
   */
  app.FilterStrokeWidget = class FilterStrokeWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = MF_OPTIONS['50'][0].value;
      const initialValue = container.getAttribute('data-initial-value');
      super('stroke', {
        defaultValue: defaultValue,
        initialValue: initialValue ? initialValue : defaultValue,
        dependency: ['gender', 'distance']
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-stroke',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.stroke'),
        options: MF_OPTIONS['50']
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }

    /**
     * dependency Staged
     *
     * Method is fired when a dependency of this filter is staged. We get
     * the staged value as the param and we update the listbox options based
     * upon the new value.
     *
     * @param {String} dependencyValue - The staged value of our dependency
     * @param {Object} filterState - The current filterState
     * @param {String} dependencyKey - The key of our staged depdency
     */
    dependencyStaged(dependencyValue, filterState, dependencyKey) {
      const currentGender = filterState.stage.gender || filterState.values.gender;
      if (dependencyKey === 'gender') {
        if (dependencyValue === 'X') {
          this.updateListboxOptions(X_OPTIONS);
        } else {
          const currentDistance = filterState.stage.distance || filterState.values.distance;
          this.updateListboxOptions(MF_OPTIONS[String(currentDistance)]);
        }
      } else if (dependencyKey === 'distance' && currentGender !== 'X') {
        this.updateListboxOptions(MF_OPTIONS[String(dependencyValue)]);
      }
    }

    /**
     * Update Listbox Options
     *
     * Take a set of options, look to see if the current value of the filter
     * is in those options, if it is, then render the listbox and pick that
     * value. Otherwise, re-render the filter picking the first item as the
     * selected value and also fire a change call for the store.
     *
     * @param {Array} options - Options array of value/label objects
     */
    updateListboxOptions(options) {
      if (options.find(option => option.value === this.value) ? true : false) {
        this.listbox.render(options, this.value);
      } else {
        this.listbox.render(options);
        super.change(options[0].value);
      }
    }
  };

  /**
   * Get Options Array
   *
   * Maps an array of values into an array of both the values and the labels
   * from the ALL_OPTIONS array.
   *
   * @param {Array} values - An array of values that are found in ALL_OPTIONS
   * @returns {Array} An array of full value and label objects for each option
   */
  const _getOptionsArray = values => values.map(value => ALL_OPTIONS[value]);

  /**
   * @const {Object} MF_OPTIONS - Strokes available at each distance for both Men and Women
   */
  const MF_OPTIONS = {
    50: _getOptionsArray(['FREESTYLE', 'BACKSTROKE', 'BREASTSTROKE', 'BUTTERFLY', 'FREESTYLE_RELAY', 'MEDLEY_RELAY']),
    100: _getOptionsArray(['FREESTYLE', 'BACKSTROKE', 'BREASTSTROKE', 'BUTTERFLY', 'MEDLEY', 'FREESTYLE_RELAY', 'MEDLEY_RELAY']),
    200: _getOptionsArray(['FREESTYLE', 'BACKSTROKE', 'BREASTSTROKE', 'BUTTERFLY', 'MEDLEY', 'FREESTYLE_RELAY']),
    400: _getOptionsArray(['FREESTYLE', 'MEDLEY']),
    800: _getOptionsArray(['FREESTYLE']),
    1500: _getOptionsArray(['FREESTYLE'])
  };

  /**
   * @const {Object} X_OPTIONS - Strokes available for all distances for mixed gender
   */
  const X_OPTIONS = _getOptionsArray(['FREESTYLE_RELAY', 'MEDLEY_RELAY']);
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * @const {Array} OPTIONS - The options that power the listbox
   */
  const OPTIONS = [{
    value: 'ALL_TIMES',
    label: PULSE.I18N.lookup('label.filters.timesMode.all')
  }, {
    value: 'BEST_TIMES',
    label: PULSE.I18N.lookup('label.filters.timesMode.best')
  }];

  /**
   * Filter - Gender
   * @extends app.Filter
   */
  app.FilterTimesModesWidget = class FilterTimesModesWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const defaultValue = OPTIONS[0].value;
      const initialValue = container.getAttribute('data-initial-value');
      super('timesMode', {
        defaultValue: defaultValue,
        initialValue: initialValue ? initialValue : defaultValue
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-times-mode',
        selectCallback: value => super.change(value),
        label: PULSE.I18N.lookup('label.filters.timesMode'),
        options: OPTIONS,
        cssClass: 'listbox--wide'
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }
  };
})(PULSE.app);
"use strict";

(function (app) {
  'use strict';

  /**
   * Filter - Year
   * @extends app.Filter
   */
  app.FilterYearWidget = class FilterYearWidget extends app.Filter {
    /**
     * Constructor
     *
     * Fires the super passing the name and config and creates the listbox
     * @param { HTMLElement } container - container that widget is instantiated on
     */
    constructor(container) {
      const OPTIONS = container.getAttribute('data-options').replace(' ', '').split(',').map(year => Number(year));
      const defaultYear = Number(container.getAttribute('data-default'));
      super('year', {
        defaultValue: defaultYear
      });

      // Create listbox UI for the filter
      this.listbox = new app.Listbox(container, {
        id: 'filter-year',
        selectCallback: value => super.change(Number(value)),
        label: PULSE.I18N.lookup('label.filters.year'),
        options: OPTIONS
      });
    }

    /**
     * Update UI
     *
     * Called when the filter is modified outside of the UI so the UI can
     * keep up to date.
     *
     * @param {*} value - The new value from the store
     * @returns {Boolean} - The result of the listbox.setSelectByValue
     */
    updateUI(value) {
      return this.listbox.setSelectByValue(value);
    }
  };
})(PULSE.app);